<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <title>OSM Navigation + GPX + BLE (framed)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body { font-family: Arial; margin: 0; display: flex; flex-direction: column; height: 100vh; }
    #map { flex: 1; }
    #controls {
      padding: 10px;
      background: #f4f4f4;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      border-top: 1px solid #ccc;
    }
    input[type="text"] { padding: 6px; width: 260px }
    button { padding: 6px 10px }
    #log {
      height: 160px;
      overflow: auto;
      background: #111;
      color: #0f0;
      border-top: 1px solid #333;
      font-size: 13px;
      padding: 8px;
      white-space: pre-wrap;
    }
    #progress {
      margin-left: 10px;
      color: green;
      font-weight: bold;
    }
    .hidden { display: none !important; }
    fieldset { border: 1px solid #ddd; padding: 6px 10px; }
    legend { font-weight: bold; }
  </style>
</head>
<body>

<div id="map"></div>

<div id="controls">
  <fieldset>
    <legend>ƒêi·ªÉm ƒë·∫øn (OSRM)</legend>
    <input id="destInput" type="text" placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ (v√≠ d·ª•: B·∫øn Th√†nh)" />
    <button id="btnRoute">T√≠nh ƒë∆∞·ªùng</button>
  </fieldset>

  <fieldset>
    <legend>GPX (OsmAnd)</legend>
    <input type="file" id="gpxFile" accept=".gpx" />
    <button id="btnLoadGPX">N·∫°p GPX</button>
  </fieldset>

  <fieldset id="bleBlock">
    <legend>BLE</legend>
    <button id="btnScan">üîç Qu√©t BLE</button>
    <select id="deviceList" style="min-width:220px"></select>
    <button id="btnConnect">K·∫øt n·ªëi</button>
    <button id="btnDisconnect">Ng·∫Øt</button>
    <span id="bleStatus">Ch∆∞a k·∫øt n·ªëi</span>
  </fieldset>

  <fieldset>
    <legend>G·ª≠i xu·ªëng ESP32</legend>
    <button id="btnSendRoute">‚¨á G·ª≠i d·ªØ li·ªáu Route</button>
    <span id="progress">Ch∆∞a g·ª≠i</span>
  </fieldset>
</div>

<div id="log"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
/* ====== BLE UUIDs (Nordic UART t∆∞∆°ng ·ª©ng ESP32 code c·ªßa b·∫°n) ====== */
const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const CHAR_UUID    = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

/* ====== Map init ====== */
const map = L.map('map').setView([10.762622, 106.660172], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '¬© OpenStreetMap contributors'
}).addTo(map);

let routeLine = null;
let knownDevices = {}, connectedDevice = null, gattServer = null, writeChar = null;

/* D·ªØ li·ªáu ƒëi·ªÅu h∆∞·ªõng th·ªëng nh·∫•t (g·ª≠i cho ESP32 theo struct c·ªßa b·∫°n) */
let routePoints = []; // [{lat, lon, action, road, next, dist?}]
let fullRoute = [];   // polyline: [{lat, lon}]
let fullManeuvers = []; // t·ª´ OSRM/GPX: [{lat,lon,modifier,name,next}]

/* ====== UI helpers ====== */
const logEl = document.getElementById('log');
const bleBlock = document.getElementById('bleBlock');
const bleStatus = document.getElementById('bleStatus');
function log(...args) {
  const line = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
  const ts = new Date().toLocaleTimeString();
  logEl.textContent = `${ts}  ${line}\n` + logEl.textContent;
}
function setBLEConnectedUI(connected) {
  // ·∫®n/hi·ªán nh√≥m qu√©t ‚Äì k·∫øt n·ªëi theo y√™u c·∫ßu
  document.getElementById('btnScan').classList.toggle('hidden', connected);
  document.getElementById('deviceList').classList.toggle('hidden', connected);
  document.getElementById('btnConnect').classList.toggle('hidden', connected);
  document.getElementById('btnDisconnect').classList.toggle('hidden', !connected);
  bleStatus.textContent = connected ? 'ƒê√É K·∫æT N·ªêI' : 'Ch∆∞a k·∫øt n·ªëi';
}

/* ====== Utils ====== */
function removeAccent(str) {
  return (str || '').normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
function haversine(a, b) {
  const R = 6371000;
  const dLat = (b.lat - a.lat) * Math.PI/180;
  const dLon = (b.lon - a.lon) * Math.PI/180;
  const lat1 = a.lat * Math.PI/180;
  const lat2 = b.lat * Math.PI/180;
  const u = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
  return 2 * R * Math.atan2(Math.sqrt(u), Math.sqrt(1-u));
}
function matchManeuverAtPoint(pt, tol=1e-5) {
  return fullManeuvers.find(m => Math.abs(m.lat-pt.lat)<tol && Math.abs(m.lon-pt.lon)<tol);
}
function buildRoutePoints() {
  // Duy·ªát theo fullRoute, g·∫Øn maneuver g·∫ßn nh·∫•t (n·∫øu tr√πng to·∫° ƒë·ªô) v√† t√≠nh dist t·ªõi r·∫Ω ti·∫øp theo
  routePoints = [];
  const n = fullRoute.length;
  for (let i=0;i<n;i++) {
    const p = fullRoute[i];
    const m = matchManeuverAtPoint(p);
    // t√¨m ch·ªâ d·∫´n ti·∫øp theo t·ª´ i+1
    let nextTurnIdx = -1;
    for (let j=i+1;j<n;j++) {
      const m2 = matchManeuverAtPoint(fullRoute[j]);
      if (m2 && (m2.modifier||'') !== 'straight') { nextTurnIdx = j; break; }
    }
    const dist = nextTurnIdx>i ? Math.round(haversine(p, fullRoute[nextTurnIdx])) : 0;
    routePoints.push({
      lat: p.lat,
      lon: p.lon,
      action: m ? (m.modifier || 'straight') : 'none',
      road: m ? removeAccent(m.name || '') : '',
      next: m ? removeAccent(m.next || '') : '',
      dist
    });
  }
}

/* ====== Geocode & OSRM ====== */
async function geocode(q) {
  const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
  const js = await res.json();
  return js.length ? { lat: +js[0].lat, lon: +js[0].lon } : null;
}
async function computeRoute(lat0, lon0, lat1, lon1) {
  const url = `https://router.project-osrm.org/route/v1/driving/${lon0},${lat0};${lon1},${lat1}?overview=full&geometries=geojson&steps=true`;
  const res = await fetch(url);
  const data = await res.json();
  return data.routes?.[0];
}

/* ====== N√∫t T√≠nh ƒë∆∞·ªùng (OSRM) ====== */
document.getElementById('btnRoute').addEventListener('click', async () => {
  // N·∫øu ƒë√£ c√≥ GPX th√¨ ch·ªâ c·∫ßn d·ª±ng routePoints t·ª´ GPX, kh√¥ng g·ªçi OSRM
  if (fullRoute.length>0 && fullManeuvers.length>=0 && document.getElementById('gpxFile').files.length>0) {
    buildRoutePoints();
    if (routeLine) map.removeLayer(routeLine);
    routeLine = L.polyline(fullRoute.map(p => [p.lat,p.lon]), { color: 'green' }).addTo(map);
    map.fitBounds(routeLine.getBounds());
    log('üìÇ D√πng d·ªØ li·ªáu t·ª´ GPX. ƒêi·ªÉm:', fullRoute.length, 'b∆∞·ªõc:', fullManeuvers.length);
    return;
  }

  const destText = document.getElementById('destInput').value.trim();
  if (!destText) return alert('Nh·∫≠p ƒë·ªãa ƒëi·ªÉm');

  const pos = await new Promise((res, rej) =>
    navigator.geolocation.getCurrentPosition(res, rej, {
      enableHighAccuracy: true, timeout: 10000, maximumAge: 0
    })
  );
  const { latitude, longitude } = pos.coords;
  const dest = await geocode(destText);
  if (!dest) return alert('Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ n√†y');

  log('üöó G·ªçi OSRM‚Ä¶');
  const route = await computeRoute(latitude, longitude, dest.lat, dest.lon);
  if (!route) return alert('Kh√¥ng t√≠nh ƒë∆∞·ª£c l·ªô tr√¨nh');

  fullRoute = route.geometry.coordinates.map(c => ({ lat: c[1], lon: c[0] }));
  fullManeuvers = (route.legs?.[0]?.steps || []).map(s => ({
    lat: s.maneuver.location[1],
    lon: s.maneuver.location[0],
    modifier: s.maneuver.modifier || 'straight',
    name: removeAccent(s.name || ''),
    next: removeAccent(s.destinations || '')
  }));

  buildRoutePoints();

  if (routeLine) map.removeLayer(routeLine);
  routeLine = L.polyline(fullRoute.map(p => [p.lat, p.lon]), { color: 'blue' }).addTo(map);
  map.fitBounds(routeLine.getBounds());
  log('‚úÖ OSRM xong:', fullRoute.length, 'ƒëi·ªÉm ‚Äì', fullManeuvers.length, 'maneuver');
});

/* ====== GPX ====== */
document.getElementById('btnLoadGPX').addEventListener('click', async () => {
  const f = document.getElementById('gpxFile').files[0];
  if (!f) return alert('Ch·ªçn file GPX tr∆∞·ªõc');
  const text = await f.text();
  parseGPX(text);
});
function parseGPX(gpxText) {
  const parser = new DOMParser();
  const xml = parser.parseFromString(gpxText, "application/xml");

  fullRoute = []; fullManeuvers = [];

  // track points
  const trkpts = xml.getElementsByTagName("trkpt");
  for (let pt of trkpts) {
    const lat = parseFloat(pt.getAttribute("lat"));
    const lon = parseFloat(pt.getAttribute("lon"));
    fullRoute.push({ lat, lon });
  }
  // route points as maneuvers
  const rtepts = xml.getElementsByTagName("rtept");
  for (let pt of rtepts) {
    const lat = parseFloat(pt.getAttribute("lat"));
    const lon = parseFloat(pt.getAttribute("lon"));
    let name = "", desc = "";
    if (pt.getElementsByTagName("name")[0]) name = pt.getElementsByTagName("name")[0].textContent;
    if (pt.getElementsByTagName("desc")[0]) desc = pt.getElementsByTagName("desc")[0].textContent;
    fullManeuvers.push({
      lat, lon,
      modifier: (name||'straight').toLowerCase(),
      name: removeAccent(desc||''),
      next: ''
    });
  }
  if (fullRoute.length === 0 && fullManeuvers.length > 0) {
    fullRoute = fullManeuvers.map(m => ({ lat: m.lat, lon: m.lon }));
  }
  if (fullRoute.length === 0) {
    alert('Kh√¥ng th·∫•y to·∫° ƒë·ªô trong GPX'); return;
  }

  buildRoutePoints();

  if (routeLine) map.removeLayer(routeLine);
  routeLine = L.polyline(fullRoute.map(p => [p.lat,p.lon]), { color: 'green' }).addTo(map);
  map.fitBounds(routeLine.getBounds());
  log(`‚úÖ GPX: ${fullRoute.length} ƒëi·ªÉm, ${fullManeuvers.length} b∆∞·ªõc`);
}

/* ====== BLE ====== */
document.getElementById('btnScan').addEventListener('click', async () => {
  try {
    log('üîç ƒêang qu√©t BLE‚Ä¶');
    const device = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: [SERVICE_UUID]
    });
    knownDevices[device.id] = device;
    const opt = new Option(device.name || `Device ${device.id.slice(0,6)}`, device.id);
    document.getElementById('deviceList').appendChild(opt);
    document.getElementById('deviceList').value = device.id;
    log('ƒê√£ th√™m thi·∫øt b·ªã:', device.name || device.id);
  } catch (err) {
    log('L·ªói qu√©t BLE:', err);
  }
});

document.getElementById('btnConnect').addEventListener('click', async () => {
  const id = document.getElementById('deviceList').value;
  const device = knownDevices[id];
  if (!device) return alert('Ch∆∞a ch·ªçn thi·∫øt b·ªã');
  try {
    gattServer = await device.gatt.connect();
    device.addEventListener('gattserverdisconnected', () => {
      log('‚ö†Ô∏è M·∫•t k·∫øt n·ªëi BLE');
      setBLEConnectedUI(false);
      connectedDevice = null; writeChar = null; gattServer = null;
    });
    const service = await gattServer.getPrimaryService(SERVICE_UUID);
    writeChar = await service.getCharacteristic(CHAR_UUID);
    connectedDevice = device;
    setBLEConnectedUI(true);
    log('‚úÖ ƒê√£ k·∫øt n·ªëi BLE:', device.name || device.id);
  } catch (err) {
    log('L·ªói k·∫øt n·ªëi:', err);
  }
});

document.getElementById('btnDisconnect').addEventListener('click', () => {
  if (connectedDevice && connectedDevice.gatt.connected) {
    connectedDevice.gatt.disconnect();
    log('ƒê√£ ng·∫Øt k·∫øt n·ªëi');
  }
});

/* ====== G·ª¨I D·ªÆ LI·ªÜU ‚Äì d√πng framing ƒë·ªÉ ESP32 parse an to√†n ====== */
/* ESP32 s·∫Ω c·ªông d·ªìn chu·ªói t·ª´ <BEGIN> t·ªõi <END> r·ªìi m·ªõi deserializeJson() */
async function bleWriteString(str) {
  const enc = new TextEncoder();
  // Chia nh·ªè ƒë·ªÉ tr√°nh v∆∞·ª£t MTU (gi·ªØ ~180 byte/khung cho an to√†n)
  const CHUNK = 180;
  for (let i=0; i<str.length; i+=CHUNK) {
    const chunk = str.substring(i, i+CHUNK);
    await writeChar.writeValue(enc.encode(chunk));
    // nho nh·ªè delay ƒë·ªÉ tr√°nh ngh·∫Ωn
    await new Promise(r => setTimeout(r, 8));
  }
}

document.getElementById('btnSendRoute').addEventListener('click', async () => {
  if (!writeChar || !connectedDevice) return alert('Ch∆∞a k·∫øt n·ªëi BLE');
  if (!routePoints.length) return alert('Ch∆∞a c√≥ tuy·∫øn ƒë·ªÉ g·ª≠i');

  const progressEl = document.getElementById('progress');

  // Chu·∫©n b·ªã JSON ƒë√∫ng schema ESP32: m·∫£ng c√°c ƒëi·ªÉm {lat,lon,action,road,next}
  const payload = routePoints.map(p => ({
    lat: p.lat, lon: p.lon, action: p.action, road: p.road, next: p.next
  }));
  const json = JSON.stringify(payload);

  try {
    log('üì¶ ƒêang g·ª≠i (framed)‚Ä¶ k√≠ch th∆∞·ªõc:', json.length, 'bytes');

    // G·ª≠i header BEGIN
    await bleWriteString('<BEGIN>\n');
    // G·ª≠i n·ªôi dung JSON chia chunk
    await bleWriteString(json);
    // G·ª≠i footer END
    await bleWriteString('\n<END>\n');

    progressEl.textContent = 'ƒê√£ g·ª≠i 100%';
    log('üì§ G·ª≠i xong!');
  } catch (e) {
    log('‚ùå G·ª≠i BLE th·∫•t b·∫°i:', e);
  }
});

// Kh·ªüi t·∫°o UI
setBLEConnectedUI(false);
</script>
</body>
</html>

