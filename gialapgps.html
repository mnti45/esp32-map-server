<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Bản đồ OSRM + GPX + BLE</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  #map { height: 80vh; }
  #controls { padding: 10px; background: #f0f0f0; }
  button, input[type=file] { margin: 5px; }
</style>
</head>
<body>

<div id="controls">
  <input type="text" id="start" placeholder="Điểm xuất phát"/>
  <input type="text" id="end" placeholder="Điểm đến"/>
  <button id="btnRoute">🚗 Tính đường</button>

  <input type="file" id="gpxFile" accept=".gpx" />
  <button id="btnLoadGPX">📂 Nạp GPX</button>
  
  <button id="btnBLE">🔍 Quét & kết nối ESP32</button>
  <button id="btnSendBLE">📤 Gửi dữ liệu cho ESP32</button>
</div>

<div id="map"></div>

<pre id="log" style="padding:10px;background:#eee;height:15vh;overflow:auto;"></pre>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
let map = L.map('map').setView([10.762622, 106.660172], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OSM contributors'
}).addTo(map);

let routeLine = null;
let fullRoute = [];
let fullManeuvers = [];

// BLE vars
let bleDevice = null;
let bleCharacteristic = null;

// BLE UUIDs (cần thay bằng UUID ESP32 bạn dùng)
const SERVICE_UUID = '0000ffe0-0000-1000-8000-00805f9b34fb';
const CHARACTERISTIC_UUID = '0000ffe1-0000-1000-8000-00805f9b34fb';

function log(msg) {
  document.getElementById('log').textContent += msg + "\n";
}

function removeAccent(str) {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

// ====================== OSRM & GPX ======================
document.getElementById('btnRoute').addEventListener('click', async () => {
  if (fullRoute.length > 0) {
    log("📂 Đang dùng dữ liệu GPX (không gọi OSRM)");
    if (routeLine) map.removeLayer(routeLine);
    routeLine = L.polyline(fullRoute.map(p => [p.lat, p.lon]), { color: 'green' }).addTo(map);
    map.fitBounds(routeLine.getBounds());
    return;
  }

  const start = document.getElementById('start').value;
  const end = document.getElementById('end').value;
  if (!start || !end) return alert('Nhập đủ điểm xuất phát và điểm đến');

  log("🚗 Đang gọi OSRM để tính đường...");
  const url = `https://router.project-osrm.org/route/v1/driving/${start};${end}?overview=full&geometries=geojson&steps=true`;
  const res = await fetch(url);
  const data = await res.json();

  if (data.routes && data.routes.length > 0) {
    const coords = data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
    if (routeLine) map.removeLayer(routeLine);
    routeLine = L.polyline(coords, { color: 'blue' }).addTo(map);
    map.fitBounds(routeLine.getBounds());
    log("✅ Đã vẽ tuyến đường bằng OSRM");

    fullManeuvers = [];
    for (let leg of data.routes[0].legs) {
      for (let step of leg.steps) {
        fullManeuvers.push({
          lat: step.maneuver.location[1],
          lon: step.maneuver.location[0],
          modifier: step.maneuver.modifier || '',
          name: removeAccent(step.name || ''),
          next: ''
        });
      }
    }
    log(`📜 OSRM Maneuvers: ${fullManeuvers.length} bước`);
  } else {
    log("❌ Không tìm thấy tuyến đường");
  }
});

document.getElementById('btnLoadGPX').addEventListener('click', async () => {
  const fileInput = document.getElementById('gpxFile');
  if (!fileInput.files.length) return alert('Chọn file GPX trước');

  const file = fileInput.files[0];
  const text = await file.text();
  parseGPX(text);
});

function parseGPX(gpxText) {
  const parser = new DOMParser();
  const xml = parser.parseFromString(gpxText, "application/xml");

  fullRoute = [];
  fullManeuvers = [];

  const trkpts = xml.getElementsByTagName("trkpt");
  for (let pt of trkpts) {
    const lat = parseFloat(pt.getAttribute("lat"));
    const lon = parseFloat(pt.getAttribute("lon"));
    fullRoute.push({ lat, lon });
  }

  const rtepts = xml.getElementsByTagName("rtept");
  for (let pt of rtepts) {
    const lat = parseFloat(pt.getAttribute("lat"));
    const lon = parseFloat(pt.getAttribute("lon"));
    let name = "";
    let desc = "";
    if (pt.getElementsByTagName("name")[0]) name = pt.getElementsByTagName("name")[0].textContent;
    if (pt.getElementsByTagName("desc")[0]) desc = pt.getElementsByTagName("desc")[0].textContent;

    fullManeuvers.push({
      lat, lon,
      modifier: name || 'straight',
      name: removeAccent(desc || ''),
      next: ''
    });
  }

  if (fullRoute.length === 0 && fullManeuvers.length > 0) {
    fullRoute = fullManeuvers.map(m => ({ lat: m.lat, lon: m.lon }));
  }

  if (fullRoute.length === 0) {
    alert("Không tìm thấy dữ liệu tọa độ trong file GPX");
    return;
  }

  if (routeLine) map.removeLayer(routeLine);
  routeLine = L.polyline(fullRoute.map(p => [p.lat, p.lon]), { color: 'green' }).addTo(map);
  map.fitBounds(routeLine.getBounds());

  log(`✅ Đã nạp GPX: ${fullRoute.length} điểm, ${fullManeuvers.length} bước điều hướng`);
}

document.getElementById('start').addEventListener('input', () => { fullRoute = []; });
document.getElementById('end').addEventListener('input', () => { fullRoute = []; });

// ====================== BLE ======================
document.getElementById('btnBLE').addEventListener('click', async () => {
  try {
    log("🔍 Đang quét thiết bị BLE...");
    bleDevice = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: [SERVICE_UUID]
    });

    const server = await bleDevice.gatt.connect();
    const service = await server.getPrimaryService(SERVICE_UUID);
    bleCharacteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);

    log(`✅ Đã kết nối tới: ${bleDevice.name}`);
  } catch (error) {
    log("❌ Lỗi BLE: " + error);
  }
});

document.getElementById('btnSendBLE').addEventListener('click', async () => {
  if (!bleCharacteristic) return alert("Chưa kết nối BLE");

  const data = {
    route: fullRoute,
    maneuvers: fullManeuvers
  };
  const jsonString = JSON.stringify(data);

  try {
    const encoder = new TextEncoder();
    const chunkSize = 200; // BLE packet size limit
    for (let i = 0; i < jsonString.length; i += chunkSize) {
      const chunk = jsonString.substring(i, i + chunkSize);
      await bleCharacteristic.writeValue(encoder.encode(chunk));
    }
    log("📤 Đã gửi dữ liệu điều hướng tới ESP32");
  } catch (error) {
    log("❌ Gửi BLE thất bại: " + error);
  }
});
</script>
</body>
</html>

