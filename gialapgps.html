<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <title>OSM Navigation + BLE</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #sentDataContainer {
      padding: 8px 12px;
      background: #eef6ff;
      font-size: 12px;
      max-height: 120px;
      overflow: auto;
      border-bottom: 1px solid #ccc;
      flex-shrink: 0;
    }
    #sentData {
      width: 100%;
      height: 80px;
      font-family: monospace;
      white-space: pre-wrap;
      overflow-wrap: break-word;
      resize: none;
    }
    #copyBtn {
      margin-top: 6px;
      font-size: 12px;
      padding: 4px 8px;
      cursor: pointer;
    }
    #map {
      flex: 1 1 auto;
      height: auto;
      min-height: 400px;
    }
    #controls {
      padding: 12px 10px;
      background: #f9f9f9;
      border-top: 1px solid #ccc;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    #controls > div {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    input[type="text"] {
      padding: 6px 8px;
      width: 250px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    select {
      padding: 6px 8px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #ccc;
      min-width: 220px;
    }
    button {
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #007bff;
      background: #007bff;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:hover {
      background: #0056b3;
    }
    #progress {
      font-weight: 600;
      color: green;
      min-width: 130px;
      text-align: center;
    }
    progress {
      width: 200px;
      height: 14px;
      border-radius: 6px;
      overflow: hidden;
    }
  </style>
</head>
<body>

<div id="sentDataContainer">
  <strong>D·ªØ li·ªáu ƒë√£ g·ª≠i xu·ªëng ESP32:</strong>
  <textarea id="sentData" readonly></textarea>
  <button id="copyBtn">üìã Copy d·ªØ li·ªáu</button>
</div>

<div id="map"></div>

<div id="controls">
  <div>
    <strong>ƒêi·ªÉm ƒë·∫øn:</strong>
    <input id="destInput" type="text" placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ (VD: B·∫øn Th√†nh)" />
    <button id="btnRoute">T√≠nh ƒë∆∞·ªùng</button>
  </div>

  <div>
    <button id="btnScan">üîç Qu√©t BLE</button>
    <select id="deviceList" style="min-width:220px"></select>
    <button id="btnConnect">K·∫øt n·ªëi</button>
    <button id="btnDisconnect">Ng·∫Øt</button>
  </div>

  <div>
    <strong>Tuy·∫øn ƒë∆∞·ªùng:</strong>
    <select id="routeSelect" style="min-width:240px"></select>
  </div>

  <div>
    <button id="btnSendRoute">‚¨á G·ª≠i d·ªØ li·ªáu Route</button>
    <span id="progress">Ch∆∞a g·ª≠i</span>
    <progress id="progressBar" value="0" max="100"></progress>
  </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
// --- BLE UUIDs ---
const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

// Bi·∫øn qu·∫£n l√Ω BLE
let knownDevices = {};
let connectedDevice = null;
let gattServer = null;
let writeChar = null;

// Bi·∫øn qu·∫£n l√Ω b·∫£n ƒë·ªì, route
let map, currentPositionMarker = null, routeLayer = null;
let routesData = [];
let fullRoute = [];

// --- Kh·ªüi t·∫°o b·∫£n ƒë·ªì Leaflet ---
function initMap() {
  map = L.map('map').setView([10.7769, 106.7009], 13); // trung t√¢m TP.HCM l√†m m·∫∑c ƒë·ªãnh

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
  }).addTo(map);

  // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(pos => {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      currentPositionMarker = L.marker([lat, lon]).addTo(map).bindPopup("V·ªã tr√≠ hi·ªán t·∫°i").openPopup();
      map.setView([lat, lon], 14);
    }, err => {
      alert("Kh√¥ng l·∫•y ƒë∆∞·ª£c v·ªã tr√≠ hi·ªán t·∫°i: " + err.message);
    });
  } else {
    alert("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Geolocation");
  }
}

// --- X√≥a tuy·∫øn ƒë∆∞·ªùng c≈© ---
function clearRoutes() {
  if (routeLayer) {
    map.removeLayer(routeLayer);
    routeLayer = null;
  }
}

// --- Hi·ªÉn th·ªã tuy·∫øn ƒë√£ ch·ªçn ---
function selectRoute(index) {
  clearRoutes();
  if (!routesData || !routesData[index]) return;

  const route = routesData[index];
  routeLayer = L.geoJSON(route.geometry, {
    style: { color: 'blue', weight: 5 }
  }).addTo(map);

  // Zoom t·ªõi tuy·∫øn ƒë∆∞·ªùng
  map.fitBounds(routeLayer.getBounds());

  // L∆∞u d·ªØ li·ªáu route ƒë·ªÉ g·ª≠i BLE (chuy·ªÉn geojson coords sang [{lat, lon}])
  fullRoute = route.geometry.coordinates.map(coord => ({
    lat: coord[1],
    lon: coord[0],
    action: "none",
    road: "Unknown",
    next: ""
  }));

}

// --- H√†m g·ªçi API ƒë·ªãnh tuy·∫øn OSRM ---
async function computeRoute(startLat, startLon, endLat, endLon) {
  const url = `https://router.project-osrm.org/route/v1/driving/${startLon},${startLat};${endLon},${endLat}?overview=full&geometries=geojson`;
  try {
    const response = await fetch(url);
    const data = await response.json();
    if (data.code !== 'Ok' || !data.routes.length) return [];

    return data.routes.map(route => ({
      geometry: route.geometry,
      distance: route.distance,
      duration: route.duration
    }));
  } catch (e) {
    console.error('L·ªói l·∫•y tuy·∫øn:', e);
    return [];
  }
}

// --- H√†m geocode ƒë∆°n gi·∫£n qua Nominatim ---
async function geocode(address) {
  const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`;
  try {
    const res = await fetch(url);
    const data = await res.json();
    if (!data.length) return null;
    return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon) };
  } catch {
    return null;
  }
}

// --- BLE x·ª≠ l√Ω ng·∫Øt k·∫øt n·ªëi t·ª± ƒë·ªông ---
function onDisconnected(event) {
  alert('Thi·∫øt b·ªã ƒë√£ ng·∫Øt k·∫øt n·ªëi');
  connectedDevice = null;
  writeChar = null;
  gattServer = null;
  updateDeviceList();
}

// --- Qu√©t BLE ---
async function scanBLE() {
  try {
    const device = await navigator.bluetooth.requestDevice({
      filters: [{ name: 'ESP32-NAV' }],
      optionalServices: [SERVICE_UUID]
    });
    device.addEventListener('gattserverdisconnected', onDisconnected);
    knownDevices[device.id] = device;
    updateDeviceList();
  } catch (error) {
    console.error('Qu√©t thi·∫øt b·ªã BLE l·ªói:', error);
    alert('Qu√©t BLE th·∫•t b·∫°i: ' + error.message);
  }
}

// --- C·∫≠p nh·∫≠t danh s√°ch thi·∫øt b·ªã ---
function updateDeviceList() {
  const select = document.getElementById('deviceList');
  select.innerHTML = '';
  for (const id in knownDevices) {
    const dev = knownDevices[id];
    const option = document.createElement('option');
    option.value = id;
    option.text = dev.name || dev.id;
    select.appendChild(option);
  }
}

// --- K·∫øt n·ªëi BLE ---
async function connectBLE() {
  const select = document.getElementById('deviceList');
  const deviceId = select.value;
  if (!deviceId) {
    alert('Vui l√≤ng ch·ªçn thi·∫øt b·ªã ƒë·ªÉ k·∫øt n·ªëi');
    return;
  }
  const device = knownDevices[deviceId];
  if (!device) {
    alert('Thi·∫øt b·ªã kh√¥ng t·ªìn t·∫°i');
    return;
  }

  try {
    gattServer = await device.gatt.connect();
    gattServer.device.addEventListener('gattserverdisconnected', onDisconnected);
    const service = await gattServer.getPrimaryService(SERVICE_UUID);
    writeChar = await service.getCharacteristic(CHAR_UUID);
    connectedDevice = device;
    alert(`ƒê√£ k·∫øt n·ªëi v·ªõi ${device.name || device.id}`);
  } catch (e) {
    alert('L·ªói k·∫øt n·ªëi BLE: ' + e.message);
  }
}

// --- Ng·∫Øt k·∫øt n·ªëi BLE ---
function disconnectBLE() {
  if (gattServer && gattServer.connected) {
    gattServer.disconnect();
    alert('ƒê√£ ng·∫Øt k·∫øt n·ªëi BLE');
  }
  connectedDevice = null;
  writeChar = null;
  gattServer = null;
  updateDeviceList();
}

// --- H√†m t√¨m maneuver t·∫°i index d·ª±a tr√™n d·ªØ li·ªáu gi·∫£ ƒë·ªãnh ho·∫∑c logic th·∫≠t ---
function matchManeuverAt(index) {
  // Gi·∫£ s·ª≠ b·∫°n c√≥ data maneuvers t∆∞∆°ng ·ª©ng ho·∫∑c b·∫°n mu·ªën t·∫°m th·ªùi tr·∫£ v·ªÅ m·∫∑c ƒë·ªãnh
  // N·∫øu b·∫°n c√≥ d·ªØ li·ªáu maneuvers ch√≠nh x√°c, thay ph·∫ßn n√†y th√†nh logic l·∫•y ƒë√∫ng maneuver
  return {modifier: "straight", name: "Unknown Road", next: ""};
}

// --- H√†m t√≠nh kho·∫£ng c√°ch (m) gi·ªØa 2 ƒëi·ªÉm lat-lon (haversine formula) ---
function calculateDistance(p1, p2) {
  const R = 6371000; // b√°n k√≠nh Tr√°i ƒê·∫•t (m)
  const toRad = deg => deg * Math.PI / 180;
  const dLat = toRad(p2.lat - p1.lat);
  const dLon = toRad(p2.lon - p1.lon);
  const a = Math.sin(dLat/2)*Math.sin(dLat/2) +
            Math.cos(toRad(p1.lat))*Math.cos(toRad(p2.lat)) *
            Math.sin(dLon/2)*Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// --- T√≠nh ƒë∆∞·ªùng khi b·∫•m n√∫t ---
document.getElementById('btnRoute').addEventListener('click', async () => {
  const destAddr = document.getElementById('destInput').value.trim();
  if (!destAddr) {
    alert('Nh·∫≠p ƒë·ªãa ch·ªâ ƒë√≠ch');
    return;
  }
  if (!currentPositionMarker) {
    alert('Ch∆∞a x√°c ƒë·ªãnh v·ªã tr√≠ hi·ªán t·∫°i');
    return;
  }
  const startLat = currentPositionMarker.getLatLng().lat;
  const startLon = currentPositionMarker.getLatLng().lng;
  const destPos = await geocode(destAddr);
  if (!destPos) {
    alert('Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ ƒë√≠ch');
    return;
  }

  const routes = await computeRoute(startLat, startLon, destPos.lat, destPos.lon);
  if (!routes.length) {
    alert('Kh√¥ng t√¨m th·∫•y tuy·∫øn ƒë∆∞·ªùng');
    return;
  }
  routesData = routes;

  const selectRouteElem = document.getElementById('routeSelect');
  selectRouteElem.innerHTML = '';
  routes.forEach((r, i) => {
    const opt = document.createElement('option');
    opt.value = i;
    opt.text = `Tuy·∫øn ${i+1} - ${Math.round(r.distance/1000)} km, ${Math.round(r.duration/60)} ph√∫t`;
    selectRouteElem.appendChild(opt);
  });
  selectRouteElem.selectedIndex = 0;
  selectRoute(0);
});

// --- Ch·ªçn tuy·∫øn ƒë∆∞·ªùng khi thay ƒë·ªïi trong select ---
document.getElementById('routeSelect').addEventListener('change', (e) => {
  selectRoute(e.target.value);
});

// --- G·ª≠i d·ªØ li·ªáu route qua BLE theo chunk 20 bytes ---
async function sendRouteData() {
  if (!writeChar || !fullRoute.length) {
    alert('Ch∆∞a k·∫øt n·ªëi BLE ho·∫∑c ch∆∞a c√≥ route');
    return;
  }

  // T·∫°o d·ªØ li·ªáu route d·∫°ng JSON
  // fullRoute = [{lat, lon, action, road, next},...]
  // C·∫Øt th√†nh chunk <= 20 bytes (v√¨ BLE MTU 23 byte, d·ªØ li·ªáu th·ª±c 20)
  // ·ªû ƒë√¢y s·∫Ω chuy·ªÉn d·ªØ li·ªáu sang chu·ªói JSON thu g·ªçn, r·ªìi c·∫Øt
  // C√≥ th·ªÉ t·ªëi ∆∞u nh·ªã ph√¢n nh∆∞ng ƒë∆°n gi·∫£n d√πng text

  // B·ªï sung h√†nh ƒë·ªông theo maneuver
  fullRoute.forEach((pt, idx) => {
    const man = matchManeuverAt(idx);
    pt.action = man.modifier || "none";
    pt.road = man.name || "Unknown";
    pt.next = man.next || "";
  });

  const jsonStr = JSON.stringify(fullRoute);
  const encoder = new TextEncoder();
  const data = encoder.encode(jsonStr);

  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progress');
  const sentDataArea = document.getElementById('sentData');

  progressBar.value = 0;
  progressBar.max = data.length;
  progressText.textContent = 'ƒêang g·ª≠i d·ªØ li·ªáu...';

  sentDataArea.value = "";

  try {
    let offset = 0;
    const chunkSize = 20;
    while (offset < data.length) {
      const chunk = data.slice(offset, offset + chunkSize);
      await writeChar.writeValue(chunk);
      offset += chunkSize;
      progressBar.value = offset;
      progressText.textContent = `ƒê√£ g·ª≠i ${offset} / ${data.length} bytes`;
      // C·∫≠p nh·∫≠t hi·ªÉn th·ªã text ƒë√£ g·ª≠i
      sentDataArea.value = jsonStr.slice(0, offset);
      await new Promise(r => setTimeout(r, 30)); // tr√°nh g·ª≠i nhanh qu√°
    }
    progressText.textContent = "G·ª≠i d·ªØ li·ªáu ho√†n th√†nh!";
  } catch (err) {
    progressText.textContent = "L·ªói khi g·ª≠i d·ªØ li·ªáu: " + err.message;
  }
}

// --- C√°c n√∫t b·∫•m ---
document.getElementById('btnScan').addEventListener('click', scanBLE);
document.getElementById('btnConnect').addEventListener('click', connectBLE);
document.getElementById('btnDisconnect').addEventListener('click', disconnectBLE);
document.getElementById('btnSendRoute').addEventListener('click', sendRouteData);

// --- Copy d·ªØ li·ªáu ƒë√£ g·ª≠i ---
document.getElementById('copyBtn').addEventListener('click', () => {
  const sentData = document.getElementById('sentData');
  sentData.select();
  document.execCommand('copy');
  alert('ƒê√£ sao ch√©p d·ªØ li·ªáu ƒë√£ g·ª≠i');
});

// --- Kh·ªüi t·∫°o ---
initMap();

</script>

</body>
</html>
