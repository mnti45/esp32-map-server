<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <title>OSM Navigation + BLE</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body {
      font-family: Arial;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #log {
      height: 140px;
      overflow: auto;
      background: #fff;
      border-bottom: 1px solid #ddd;
      font-size: 13px;
      padding: 8px;
    }
    #map {
      flex: 1;
    }
    #controls {
      padding: 10px;
      background: #f4f4f4;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      border-top: 1px solid #ccc;
    }
    input[type="text"] {
      padding: 6px;
      width: 260px;
    }
    button {
      padding: 6px 10px;
    }
    #progress {
      margin-left: 10px;
      color: green;
      font-weight: bold;
    }
    #sentDataContainer {
      padding: 10px;
      background: #eef;
      font-size: 12px;
      max-height: 200px;
      overflow: auto;
      border-top: 1px solid #ccc;
    }
    #sentData {
      width: 100%;
      height: 180px;
      font-family: monospace;
      white-space: pre-wrap;
      overflow-wrap: break-word;
    }
  </style>
</head>
<body>

<div id="log"></div>

<div id="map"></div>

<div id="controls">
  <div>
    <strong>ƒêi·ªÉm ƒë·∫øn:</strong>
    <input id="destInput" type="text" placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ (v√≠ d·ª•: B·∫øn Th√†nh)" />
    <button id="btnRoute">T√≠nh ƒë∆∞·ªùng</button>
  </div>

  <div>
    <button id="btnScan">üîç Qu√©t BLE</button>
    <select id="deviceList" style="min-width:220px"></select>
    <button id="btnConnect">K·∫øt n·ªëi</button>
    <button id="btnDisconnect">Ng·∫Øt</button>
  </div>

  <div>
    <button id="btnSendRoute">‚¨á G·ª≠i d·ªØ li·ªáu Route</button>
    <span id="progress">Ch∆∞a g·ª≠i</span>
  </div>
</div>

<div id="sentDataContainer">
  <strong>D·ªØ li·ªáu ƒë√£ g·ª≠i xu·ªëng ESP32:</strong><br/>
  <textarea id="sentData" readonly></textarea>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

const map = L.map('map').setView([10.762622, 106.660172], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '¬© OpenStreetMap contributors'
}).addTo(map);

let routeLine = null;
let knownDevices = {}, connectedDevice = null, gattServer = null, writeChar = null;
let fullRoute = [], fullManeuvers = [];

const logEl = document.getElementById('log');
function log(...args) {
  const line = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
  logEl.innerText = new Date().toLocaleTimeString() + '  ' + line + '\n' + logEl.innerText;
}

document.getElementById('btnScan').addEventListener('click', async () => {
  try {
    const device = await navigator.bluetooth.requestDevice({
      filters: [{ name: 'ESP32-NAV' }],
      optionalServices: [SERVICE_UUID]
    });

    knownDevices[device.id] = device;

    // X√≥a danh s√°ch c≈© v√† th√™m thi·∫øt b·ªã m·ªõi
    const listEl = document.getElementById('deviceList');
    listEl.innerHTML = ''; // x√≥a c≈©
    const opt = new Option(device.name || `Device ${device.id.slice(0, 6)}`, device.id);
    listEl.appendChild(opt);
    listEl.value = device.id;

    log('T√¨m th·∫•y thi·∫øt b·ªã ESP32-NAV:', device.name || device.id);
  } catch (err) {
    log('Kh√¥ng t√¨m th·∫•y thi·∫øt b·ªã ESP32-NAV ho·∫∑c b·ªã t·ª´ ch·ªëi:', err);
  }
});


document.getElementById('btnConnect').addEventListener('click', async () => {
  const id = document.getElementById('deviceList').value;
  const device = knownDevices[id];
  if (!device) return alert('Ch∆∞a ch·ªçn thi·∫øt b·ªã');
  try {
    gattServer = await device.gatt.connect();
    const service = await gattServer.getPrimaryService(SERVICE_UUID);
    writeChar = await service.getCharacteristic(CHAR_UUID);
    connectedDevice = device;
    log('ƒê√£ k·∫øt n·ªëi BLE');
  } catch (err) {
    log('L·ªói k·∫øt n·ªëi:', err);
  }
});

document.getElementById('btnDisconnect').addEventListener('click', () => {
  if (connectedDevice && connectedDevice.gatt.connected) {
    connectedDevice.gatt.disconnect();
    log('ƒê√£ ng·∫Øt k·∫øt n·ªëi');
  }
});

function removeAccent(str) {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function geocode(q) {
  const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
  const js = await res.json();
  return js.length ? { lat: +js[0].lat, lon: +js[0].lon } : null;
}

async function computeRoute(lat0, lon0, lat1, lon1) {
  const url = `https://router.project-osrm.org/route/v1/walking/${lon0},${lat0};${lon1},${lat1}?overview=full&geometries=geojson&steps=true`;
  const res = await fetch(url);
  const data = await res.json();
  return data.routes[0];
}

function calculateDistance(a, b) {
  const R = 6371000;
  const dLat = (b.lat - a.lat) * Math.PI / 180;
  const dLon = (b.lon - a.lon) * Math.PI / 180;
  const lat1 = a.lat * Math.PI / 180;
  const lat2 = b.lat * Math.PI / 180;
  const ua = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(ua), Math.sqrt(1 - ua));
  return R * c;
}

function findNextManeuverIndex(fromIndex = 0) {
  for (let i = fromIndex; i < fullRoute.length; i++) {
    const match = matchManeuverAt(i);
    if (match && match.modifier !== 'straight') return i;
  }
  return -1;
}

function matchManeuverAt(index) {
  const p = fullRoute[index];
  return fullManeuvers.find(m =>
    Math.abs(m.lat - p.lat) < 1e-5 && Math.abs(m.lon - p.lon) < 1e-5
  );
}

document.getElementById('btnRoute').addEventListener('click', async () => {
  const destText = document.getElementById('destInput').value.trim();
  if (!destText) return alert('Nh·∫≠p ƒë·ªãa ƒëi·ªÉm');

  const pos = await new Promise((res, rej) =>
    navigator.geolocation.getCurrentPosition(res, rej, {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    })
  );

  const { latitude, longitude } = pos.coords;
  const dest = await geocode(destText);
  if (!dest) return alert('Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ n√†y');

  const route = await computeRoute(latitude, longitude, dest.lat, dest.lon);
  if (!route) return alert('Kh√¥ng t√≠nh ƒë∆∞·ª£c l·ªô tr√¨nh');

  fullRoute = route.geometry.coordinates.map(c => ({ lat: c[1], lon: c[0] }));
  fullManeuvers = (route.legs[0]?.steps || []).map(s => ({
    lat: s.maneuver.location[1],
    lon: s.maneuver.location[0],
    modifier: s.maneuver.modifier || 'straight',
    name: removeAccent(s.name || ''),
    next: removeAccent(s.destinations || '')
  }));

  if (routeLine) map.removeLayer(routeLine);
  routeLine = L.polyline(fullRoute.map(p => [p.lat, p.lon]), { color: 'blue' }).addTo(map);
  map.fitBounds(routeLine.getBounds());
  log('T√≠nh ƒë∆∞·ªùng xong:', fullRoute.length, 't·ªça ƒë·ªô -', fullManeuvers.length, 'maneuver');
});

document.getElementById('btnSendRoute').addEventListener('click', async () => {
  if (!writeChar || !connectedDevice) return alert('Ch∆∞a k·∫øt n·ªëi BLE');

  const pos = await new Promise((res, rej) =>
    navigator.geolocation.getCurrentPosition(res, rej, {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    })
  );

  const { latitude, longitude } = pos.coords;

  const payload = {
    start: {
      lat: latitude,
      lon: longitude
    },
    route: []
  };

  for (let j = 0; j < fullRoute.length; j++) {
    const p = fullRoute[j];
    const m = matchManeuverAt(j);
    const nextTurnIdx = findNextManeuverIndex(j);
    const dist = nextTurnIdx > j ? Math.round(calculateDistance(p, fullRoute[nextTurnIdx])) : 0;

    payload.route.push({
      lat: p.lat,
      lon: p.lon,
      action: m ? m.modifier : 'none',
      road: m ? m.name : '',
      next: m ? m.next : '',
      dist: dist
    });
  }

  const enc = new TextEncoder();
  const jsonStr = JSON.stringify(payload);
 
const data = enc.encode(jsonStr);
const CHUNK_SIZE = 100; // ho·∫∑c 128 ho·∫∑c 20 t√πy ESP32 b·∫°n th·ª≠
for (let i = 0; i < data.length; i += CHUNK_SIZE) {
  const chunk = data.slice(i, i + CHUNK_SIZE);
  await writeChar.writeValue(chunk);
  await new Promise(resolve => setTimeout(resolve, 30)); // delay nh·∫π ƒë·ªÉ ESP32 x·ª≠ l√Ω
}

// G·ª≠i 1 g√≥i k·∫øt th√∫c ƒë·ªÉ ESP32 bi·∫øt ƒë√£ xong
await writeChar.writeValue(enc.encode('###END###'));


  document.getElementById('sentData').value = jsonStr;
  document.getElementById('progress').innerText = "ƒê√£ g·ª≠i to√†n b·ªô d·ªØ li·ªáu";
  log("ƒê√£ g·ª≠i to√†n b·ªô route + t·ªça ƒë·ªô hi·ªán t·∫°i");
});
</script>
</body>
</html>




