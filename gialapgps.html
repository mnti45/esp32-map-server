<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<title>OSM Navigation + BLE (GPS Th·∫≠t, T·∫ßn su·∫•t g·ª≠i theo kho·∫£ng c√°ch)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  body{font-family:Arial;margin:0}
  #top { padding:10px; background:#f4f4f4; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  #map{height:60vh}
  input[type="text"]{padding:6px; width:260px}
  button{padding:6px 10px}
  #devices { margin-left:8px; }
  #log { height:160px; overflow:auto; padding:8px; background:#fff; border-top:1px solid #ddd; font-size:13px; }
  .small { font-size:13px; color:#444; }
</style>
</head>
<body>

<div id="top">
  <div>
    <strong>ƒêi·ªÉm ƒë·∫øn:</strong>
    <input id="destInput" type="text" placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ (v√≠ d·ª•: Ben Thanh, Ho Chi Minh)" />
    <button id="btnRoute">T√≠nh ƒë∆∞·ªùng</button>
  </div>

  <div>
    <button id="btnScan">üîç Qu√©t BLE</button>
    <select id="deviceList" style="min-width:220px"></select>
    <button id="btnConnect">K·∫øt n·ªëi</button>
    <button id="btnDisconnect">Ng·∫Øt</button>
  </div>

  <div>
    <button id="btnSimStart">‚ñ∂ Start Simulate (GPS Th·∫≠t)</button>
    <button id="btnSimStop">‚è∏ Stop</button>
    <label class="small">(Ph·∫£i CONNECT tr∆∞·ªõc khi simulate ƒë·ªÉ g·ª≠i BLE)</label>
  </div>
</div>

<div id="map"></div>
<div id="log"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>
/* ====== C·∫•u h√¨nh BLE UUID (ph·∫£i gi·ªëng ESP32 c·ªßa b·∫°n) ====== */
const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const CHAR_UUID    = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

/* ====== Map kh·ªüi t·∫°o ====== */
const map = L.map('map').setView([10.762622, 106.660172], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '¬© OpenStreetMap contributors'
}).addTo(map);

let userMarker = L.marker([10.762622, 106.660172]).addTo(map);
let routeLine = null;

/* ====== UI elements ====== */
const btnScan = document.getElementById('btnScan');
const deviceList = document.getElementById('deviceList');
const btnConnect = document.getElementById('btnConnect');
const btnDisconnect = document.getElementById('btnDisconnect');
const btnRoute = document.getElementById('btnRoute');
const destInput = document.getElementById('destInput');
const logEl = document.getElementById('log');
const btnSimStart = document.getElementById('btnSimStart');
const btnSimStop = document.getElementById('btnSimStop');

/* ====== State BLE ====== */
let knownDevices = {}; // id -> device object
let connectedDevice = null;
let gattServer = null;
let writeChar = null;

/* ====== Logging helper ====== */
function log(...args){
  const line = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
  logEl.innerText = (new Date().toLocaleTimeString()) + '  ' + line + '\n' + logEl.innerText;
}

/* ====== Scan BLE - must be triggered by user gesture ====== */
btnScan.addEventListener('click', async () => {
  try {
    log('Y√™u c·∫ßu ch·ªçn thi·∫øt b·ªã (m·ªü h·ªôp ch·ªçn c·ªßa tr√¨nh duy·ªát)...');
    const device = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: [SERVICE_UUID]
    });
    if (!knownDevices[device.id]) {
      knownDevices[device.id] = device;
      const opt = document.createElement('option');
      opt.value = device.id;
      opt.text = device.name || ('Device ' + device.id.slice(0,6));
      deviceList.appendChild(opt);
      log('Thi·∫øt b·ªã th√™m v√†o danh s√°ch:', device.name || device.id);
      deviceList.value = device.id;
    } else {
      log('Thi·∫øt b·ªã ƒë√£ t·ªìn t·∫°i trong danh s√°ch:', device.name || device.id);
    }
  } catch (err) {
    log('L·ªói khi qu√©t:', err);
  }
});

/* ====== Connect to selected device ====== */
btnConnect.addEventListener('click', async () => {
  const id = deviceList.value;
  if (!id) { alert('Ch∆∞a ch·ªçn thi·∫øt b·ªã'); return; }
  const device = knownDevices[id];
  if (!device) { alert('Thi·∫øt b·ªã ƒë√£ b·ªã m·∫•t, h√£y qu√©t l·∫°i'); return; }

  try {
    log('K·∫øt n·ªëi t·ªõi thi·∫øt b·ªã...', device.name || device.id);
    gattServer = await device.gatt.connect();
    connectedDevice = device;
    log('GATT connected');

    const service = await gattServer.getPrimaryService(SERVICE_UUID);
    writeChar = await service.getCharacteristic(CHAR_UUID);
    log('L·∫•y characteristic ghi th√†nh c√¥ng');

    // optional: listen for disconnect
    device.addEventListener('gattserverdisconnected', () => {
      log('Device disconnected:', device.name || device.id);
      connectedDevice = null;
      gattServer = null;
      writeChar = null;
    });

    alert('K·∫øt n·ªëi BLE th√†nh c√¥ng: ' + (device.name || device.id));
  } catch (err) {
    log('K·∫øt n·ªëi l·ªói:', err);
    alert('K·∫øt n·ªëi l·ªói: ' + (err.message || err));
  }
});

/* ====== Disconnect ====== */
btnDisconnect.addEventListener('click', () => {
  if (connectedDevice && connectedDevice.gatt.connected) {
    connectedDevice.gatt.disconnect();
    log('ƒê√£ ng·∫Øt k·∫øt n·ªëi');
  } else {
    log('Kh√¥ng c√≥ thi·∫øt b·ªã k·∫øt n·ªëi');
  }
});

/* ====== Send short message to ESP32 (string) ====== */
async function sendToESP(msg){
  if (!writeChar) {
    log('Ch∆∞a c√≥ characteristic ƒë·ªÉ ghi - ch∆∞a k·∫øt n·ªëi?');
    return;
  }
  try {
    const enc = new TextEncoder();
    await writeChar.writeValue(enc.encode(msg));
    log('G·ª≠i t·ªõi ESP32:', msg);
  } catch (err) {
    log('L·ªói g·ª≠i BLE:', err);
  }
}

/* ====== ROUTING (OSRM) ====== */
async function geocode(q){
  const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`;
  try {
    const res = await fetch(url);
    const data = await res.json();
    if (!data || data.length === 0) return null;
    return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon), display_name: data[0].display_name };
  } catch(e) {
    log('Geocode l·ªói:', e);
    return null;
  }
}

async function computeRoute(origLat, origLon, destLat, destLon){
  const url = `https://router.project-osrm.org/route/v1/driving/${origLon},${origLat};${destLon},${destLat}?overview=full&geometries=geojson&steps=true`;
  const res = await fetch(url);
  const data = await res.json();
  if (!data.routes || data.routes.length === 0) {
    throw new Error('Kh√¥ng t√¨m ƒë∆∞·ªùng');
  }
  return data.routes[0];
}

/* ====== Use current position as origin (get once) ====== */
async function getCurrentPositionPromise(){
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) return reject(new Error('GPS kh√¥ng h·ªó tr·ª£'));
    navigator.geolocation.getCurrentPosition(p => resolve(p.coords), err => reject(err), { enableHighAccuracy: true, timeout:10000 });
  });
}

/* ====== Utilities ====== */
function deg2rad(d){ return d * Math.PI/180; }
function haversine(lat1, lon1, lat2, lon2) {
  const R=6371000;
  const dLat = deg2rad(lat2-lat1);
  const dLon = deg2rad(lon2-lon1);
  const a = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(deg2rad(lat1))*Math.cos(deg2rad(lat2))*Math.sin(dLon/2)*Math.sin(dLon/2);
  const c = 2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R*c;
}
function normalizeModifier(m){
  m = (m||'straight').toLowerCase();
  if (m.includes('left')) return 'left';
  if (m.includes('right')) return 'right';
  if (m.includes('u')) return 'uturn';
  if (m.includes('straight') || m.includes('continue')) return 'straight';
  if (m.includes('roundabout')) return 'roundabout';
  return m;
}

/* ====== T√¨m maneuver ti·∫øp theo ====== */
function findNextManeuverIndex(currentIndex, maneuvers, routeCoords) {
  for (let i = 0; i < maneuvers.length; i++) {
    let minDist = Infinity;
    let closestIdx = -1;
    for (let j = currentIndex; j < routeCoords.length; j++) {
      const d = haversine(routeCoords[j][0], routeCoords[j][1], maneuvers[i].lat, maneuvers[i].lon);
      if (d < minDist) {
        minDist = d;
        closestIdx = j;
      }
    }
    if (closestIdx > currentIndex) {
      return {manIdx: i, coordIdx: closestIdx};
    }
  }
  return null;
}

/* ====== Button route behavior ====== */
let routeCoordinates = []; // array of [lat,lng]
let osrmSteps = []; // steps array from OSRM

btnRoute.addEventListener('click', async () => {
  const destText = destInput.value.trim();
  if (!destText) { alert('Nh·∫≠p ƒëi·ªÉm ƒë·∫øn'); return; }

  try {
    log('L·∫•y v·ªã tr√≠ hi·ªán t·∫°i...');
    const cur = await getCurrentPositionPromise();
    const originLat = cur.latitude;
    const originLon = cur.longitude;
    userMarker.setLatLng([originLat, originLon]);
    map.setView([originLat, originLon], 14);
    log('V·ªã tr√≠ hi·ªán t·∫°i:', originLat.toFixed(6), originLon.toFixed(6));

    log('Geocode ƒëi·ªÉm ƒë·∫øn...');
    const dest = await geocode(destText);
    if (!dest) { alert('Kh√¥ng t√¨m th·∫•y ƒë·ªãa ƒëi·ªÉm'); return; }
    log('ƒê·ªãa ƒëi·ªÉm t√¨m ƒë∆∞·ª£c:', dest.display_name, dest.lat, dest.lon);

    log('T√≠nh ƒë∆∞·ªùng v·ªõi OSRM...');
    const route = await computeRoute(originLat, originLon, dest.lat, dest.lon);

    // v·∫Ω path
    const coords = route.geometry.coordinates.map(c => [c[1], c[0]]);
    routeCoordinates = coords;
    if (routeLine) map.removeLayer(routeLine);
    routeLine = L.polyline(coords, {color:'blue', weight:5, opacity:0.8}).addTo(map);
    map.fitBounds(routeLine.getBounds());

    if (route.legs && route.legs.length && route.legs[0].steps) {
      osrmSteps = route.legs[0].steps;
      log('C√≥', osrmSteps.length, 'b∆∞·ªõc.');
      log('B∆∞·ªõc 1:', osrmSteps[0].maneuver.instruction || osrmSteps[0].maneuver.type || JSON.stringify(osrmSteps[0].maneuver));
    } else {
      osrmSteps = [];
      log('Kh√¥ng c√≥ steps chi ti·∫øt t·ª´ OSRM');
    }

    userMarker.setLatLng(routeCoordinates[0]);
    map.panTo(routeCoordinates[0]);
    log('Route ready. B·∫°n c√≥ th·ªÉ b·∫•m Start Simulate (GPS Th·∫≠t) ƒë·ªÉ g·ª≠i d·ªØ li·ªáu BLE.');
  } catch (err) {
    log('L·ªói t√≠nh ƒë∆∞·ªùng:', err);
    alert('L·ªói: ' + (err.message || err));
  }
});

/* ====== THEO D√ïI V·ªä TR√ç TH·∫¨T V√Ä G·ª¨I BLE ====== */
let watchId = null;
let lastSentPosition = null;
let currentManeuverIndex = 0;

btnSimStart.addEventListener('click', async () => {
  if (!routeCoordinates || routeCoordinates.length < 2) {
    alert('Ch∆∞a c√≥ route');
    return;
  }
  if (!writeChar) log('Ch√∫ √Ω: ch∆∞a k·∫øt n·ªëi BLE, ch·ªâ xem v·ªã tr√≠ tr√™n map.');

  // Chu·∫©n b·ªã maneuvers
  const maneuvers = osrmSteps.map(s => ({
    lat: s.maneuver.location[1],
    lon: s.maneuver.location[0],
    modifier: (s.maneuver.modifier || 'straight'),
    instruction: s.maneuver.instruction || (s.name || ''),
    name: s.name || ''
  }));

  currentManeuverIndex = 0;
  lastSentPosition = null;

  if (watchId) navigator.geolocation.clearWatch(watchId);

  watchId = navigator.geolocation.watchPosition(async pos => {
    const { latitude, longitude } = pos.coords;
    userMarker.setLatLng([latitude, longitude]);
    map.panTo([latitude, longitude]);

    // C·∫≠p nh·∫≠t maneuver index (ƒë√£ qua ƒëi·ªÉm r·∫Ω n√†o th√¨ sang ƒëi·ªÉm k·∫ø ti·∫øp)
    while (currentManeuverIndex < maneuvers.length) {
      const man = maneuvers[currentManeuverIndex];
      const distToMan = haversine(latitude, longitude, man.lat, man.lon);
      if (distToMan < 15) {
        currentManeuverIndex++;
      } else {
        break;
      }
    }

    if (currentManeuverIndex >= maneuvers.length) {
      log('ƒê√£ ƒë·∫øn n∆°i');
      if (writeChar) await sendToESP('ƒê√£ ƒë·∫øn n∆°i');
      return;
    }

    const nextMan = maneuvers[currentManeuverIndex];
    const distToNextMan = haversine(latitude, longitude, nextMan.lat, nextMan.lon);

    // T√≠nh kho·∫£ng c√°ch di chuy·ªÉn k·ªÉ t·ª´ l·∫ßn g·ª≠i tr∆∞·ªõc
    if (lastSentPosition) {
      const distMoved = haversine(latitude, longitude, lastSentPosition.lat, lastSentPosition.lon);
      let threshold = 100;

      if (distToNextMan > 1000) threshold = 100;
      else if (distToNextMan > 100) threshold = 50;
      else threshold = 10;

      if (distMoved < threshold) {
        return; // ch∆∞a ƒë·ªß di chuy·ªÉn ƒë·ªÉ g·ª≠i ti·∫øp
      }
    }

    // T√™n ƒë∆∞·ªùng hi·ªán t·∫°i
    let currentRoadName = '';
    if (currentManeuverIndex > 0 && maneuvers[currentManeuverIndex -1]) {
      currentRoadName = maneuvers[currentManeuverIndex -1].name || '';
    } else if (maneuvers.length > 0) {
      currentRoadName = maneuvers[0].name || '';
    }

    // T√™n ƒë∆∞·ªùng s·∫Øp qu·∫πo v√†o
    const nextRoadName = nextMan.name || '';

    // Chu·∫©n b·ªã text g·ª≠i
    const distText = distToNextMan >= 1000 ? (distToNextMan/1000).toFixed(1).replace('.0','') + 'km' : Math.round(distToNextMan) + 'm';

    function directionToText(dir){
      switch(dir) {
        case 'left': return 'qu·∫πo tr√°i';
        case 'right': return 'qu·∫πo ph·∫£i';
        case 'uturn': return 'quay ƒë·∫ßu';
        case 'straight': return 'ƒëi th·∫≥ng';
        case 'arrived': return 'ƒë√£ ƒë·∫øn n∆°i';
        case 'roundabout': return 'v√†o v√≤ng xuy·∫øn';
        case 'sharp left': return 'qu·∫πo tr√°i g·∫Øt';
        case 'slight left': return 'r·∫Ω nh·∫π tr√°i';
        case 'sharp right': return 'qu·∫πo ph·∫£i g·∫Øt';
        case 'slight right': return 'r·∫Ω nh·∫π ph·∫£i';
        default: return dir;
      }
    }
    const dirText = directionToText(nextMan.modifier || 'straight');

    const message = `C√≤n ${distText} n·ªØa ${dirText}. ƒê∆∞·ªùng hi·ªán t·∫°i: ${currentRoadName || 'Kh√¥ng r√µ'}, s·∫Ω qu·∫πo v√†o: ${nextRoadName || 'Kh√¥ng r√µ'}`;

    if (writeChar) await sendToESP(message);
    log(`V·ªã tr√≠ th·ª±c g·ª≠i BLE: ${latitude.toFixed(6)},${longitude.toFixed(6)};`, message);

    lastSentPosition = { lat: latitude, lon: longitude };

  }, err => {
    log('L·ªói GPS:', err.message);
  }, { enableHighAccuracy:true, maximumAge:500, timeout:10000 });
});

btnSimStop.addEventListener('click', () => {
  if (watchId) {
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
    log('D·ª´ng g·ª≠i v·ªã tr√≠ th·∫≠t');
  }
});

log('Trang s·∫µn s√†ng. L∆∞u √Ω: b·∫•m "Qu√©t BLE" ƒë·ªÉ ch·ªçn thi·∫øt b·ªã, ch·ªçn thi·∫øt b·ªã trong list v√† b·∫•m Connect tr∆∞·ªõc khi g·ª≠i.');
</script>
</body>
</html>
