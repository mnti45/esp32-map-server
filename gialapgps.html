<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <title>OSM Navigation + GPX + BLE (framed) ‚Äî Upload GPX</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body { font-family: Arial; margin: 0; display: flex; flex-direction: column; height: 100vh; }
    #map { flex: 1; }
    #controls {
      padding: 10px;
      background: #f4f4f4;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      border-top: 1px solid #ccc;
    }
    input[type="text"], select { padding: 6px; width: 260px }
    button { padding: 6px 10px }
    #log {
      height: 160px;
      overflow: auto;
      background: #111;
      color: #0f0;
      border-top: 1px solid #333;
      font-size: 13px;
      padding: 8px;
      white-space: pre-wrap;
    }
    #progress {
      margin-left: 10px;
      color: green;
      font-weight: bold;
    }
    .hidden { display: none !important; }
    fieldset { border: 1px solid #ddd; padding: 6px 10px; }
    legend { font-weight: bold; }
  </style>
</head>
<body>

<div id="map"></div>

<div id="controls">
  <fieldset>
    <legend>ƒêi·ªÉm ƒë·∫øn (OSRM)</legend>
    <input id="destInput" type="text" placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ (v√≠ d·ª•: B·∫øn Th√†nh)" />
    <button id="btnRoute">T√≠nh ƒë∆∞·ªùng</button>
  </fieldset>

  <fieldset>
    <legend>GPX (OsmAnd)</legend>
    <input type="file" id="gpxFile" accept=".gpx" />
    <button id="btnLoadGPX">N·∫°p GPX</button>
  </fieldset>

  <fieldset id="bleBlock">
    <legend>BLE</legend>
    <button id="btnScan">üîç Qu√©t BLE</button>
    <select id="deviceList" style="min-width:220px"></select>
    <button id="btnConnect">K·∫øt n·ªëi</button>
    <button id="btnDisconnect">Ng·∫Øt</button>
    <span id="bleStatus">Ch∆∞a k·∫øt n·ªëi</span>
  </fieldset>

  <fieldset>
    <legend>G·ª≠i xu·ªëng ESP32</legend>
    <button id="btnSendRoute">‚¨á G·ª≠i d·ªØ li·ªáu Route</button>
    <span id="progress">Ch∆∞a g·ª≠i</span>
  </fieldset>
</div>

<div id="log"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
/* ====== BLE UUIDs (ph·∫£i tr√πng v·ªõi ESP32) ====== */
const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const CHAR_UUID    = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

/* ====== Map init ====== */
const map = L.map('map').setView([10.762622, 106.660172], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '¬© OpenStreetMap contributors'
}).addTo(map);

let routeLine = null;
let knownDevices = {}, connectedDevice = null, gattServer = null, writeChar = null;

/* D·ªØ li·ªáu ƒëi·ªÅu h∆∞·ªõng */
let routePoints = [];    // final points to send: [{lat,lon,action,road,next,dist?}]
let fullRoute = [];      // polyline: [{lat,lon}]
let fullManeuvers = [];  // maneuvers from OSRM or GPX rtept: [{lat,lon,modifier,name,next}]

/* ====== UI helpers ====== */
const logEl = document.getElementById('log');
const bleBlock = document.getElementById('bleBlock');
const bleStatus = document.getElementById('bleStatus');
function log(...args) {
  const line = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
  const ts = new Date().toLocaleTimeString();
  logEl.textContent = `${ts}  ${line}\n` + logEl.textContent;
}
function setBLEConnectedUI(connected) {
  document.getElementById('btnScan').classList.toggle('hidden', connected);
  document.getElementById('deviceList').classList.toggle('hidden', connected);
  document.getElementById('btnConnect').classList.toggle('hidden', connected);
  document.getElementById('btnDisconnect').classList.toggle('hidden', !connected);
  bleStatus.textContent = connected ? 'ƒê√É K·∫æT N·ªêI' : 'Ch∆∞a k·∫øt n·ªëi';
}

/* ====== Utils ====== */
function removeAccent(str) {
  return (str || '').normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
function haversine(a, b) {
  const R = 6371000;
  const dLat = (b.lat - a.lat) * Math.PI/180;
  const dLon = (b.lon - a.lon) * Math.PI/180;
  const lat1 = a.lat * Math.PI/180;
  const lat2 = b.lat * Math.PI/180;
  const u = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
  return 2 * R * Math.atan2(Math.sqrt(u), Math.sqrt(1-u));
}
function matchManeuverAtPoint(pt, tol=1e-5) {
  return fullManeuvers.find(m => Math.abs(m.lat-pt.lat)<tol && Math.abs(m.lon-pt.lon)<tol);
}
function buildRoutePoints() {
  // Build routePoints array from fullRoute and fullManeuvers
  routePoints = [];
  const n = fullRoute.length;
  for (let i=0;i<n;i++) {
    const p = fullRoute[i];
    const m = matchManeuverAtPoint(p);
    // find next non-straight maneuver
    let nextTurnIdx = -1;
    for (let j=i+1;j<n;j++) {
      const m2 = matchManeuverAtPoint(fullRoute[j]);
      if (m2 && (m2.modifier || '') !== 'straight') { nextTurnIdx = j; break; }
    }
    const dist = nextTurnIdx>i ? Math.round(haversine(p, fullRoute[nextTurnIdx])) : 0;
    routePoints.push({
      lat: p.lat,
      lon: p.lon,
      action: m ? (m.modifier || 'straight') : 'none',
      road: m ? removeAccent(m.name || '') : '',
      next: m ? removeAccent(m.next || '') : '',
      dist
    });
  }
}

/* ====== Geocode & OSRM (unchanged) ====== */
async function geocode(q) {
  const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
  const js = await res.json();
  return js.length ? { lat: +js[0].lat, lon: +js[0].lon } : null;
}
async function computeRoute(lat0, lon0, lat1, lon1) {
  const url = `https://router.project-osrm.org/route/v1/driving/${lon0},${lat0};${lon1},${lat1}?overview=full&geometries=geojson&steps=true`;
  const res = await fetch(url);
  const data = await res.json();
  return data.routes?.[0];
}

/* ====== OSRM button ====== */
document.getElementById('btnRoute').addEventListener('click', async () => {
  // If GPX loaded (user likely wants to use GPX), respect that
  if (fullRoute.length>0 && document.getElementById('gpxFile').files.length>0) {
    buildRoutePoints();
    if (routeLine) map.removeLayer(routeLine);
    routeLine = L.polyline(fullRoute.map(p => [p.lat,p.lon]), { color: 'green' }).addTo(map);
    map.fitBounds(routeLine.getBounds());
    log('üìÇ D√πng d·ªØ li·ªáu t·ª´ GPX. ƒêi·ªÉm:', fullRoute.length, 'b∆∞·ªõc:', fullManeuvers.length);
    return;
  }

  const destText = document.getElementById('destInput').value.trim();
  if (!destText) return alert('Nh·∫≠p ƒë·ªãa ƒëi·ªÉm');

  const pos = await new Promise((res, rej) =>
    navigator.geolocation.getCurrentPosition(res, rej, {
      enableHighAccuracy: true, timeout: 10000, maximumAge: 0
    })
  );
  const { latitude, longitude } = pos.coords;
  const dest = await geocode(destText);
  if (!dest) return alert('Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ n√†y');

  log('üöó G·ªçi OSRM‚Ä¶');
  const route = await computeRoute(latitude, longitude, dest.lat, dest.lon);
  if (!route) return alert('Kh√¥ng t√≠nh ƒë∆∞·ª£c l·ªô tr√¨nh');

  fullRoute = route.geometry.coordinates.map(c => ({ lat: c[1], lon: c[0] }));
  fullManeuvers = (route.legs?.[0]?.steps || []).map(s => ({
    lat: s.maneuver.location[1],
    lon: s.maneuver.location[0],
    modifier: s.maneuver.modifier || 'straight',
    name: removeAccent(s.name || ''),
    next: removeAccent(s.destinations || '')
  }));

  buildRoutePoints();

  if (routeLine) map.removeLayer(routeLine);
  routeLine = L.polyline(fullRoute.map(p => [p.lat, p.lon]), { color: 'blue' }).addTo(map);
  map.fitBounds(routeLine.getBounds());
  log('‚úÖ OSRM xong:', fullRoute.length, 'ƒëi·ªÉm ‚Äì', fullManeuvers.length, 'maneuver');
});

/* ====== GPX parsing ====== */
document.getElementById('btnLoadGPX').addEventListener('click', async () => {
  const f = document.getElementById('gpxFile').files[0];
  if (!f) return alert('Ch·ªçn file GPX tr∆∞·ªõc');
  const text = await f.text();
  parseGPX(text);
});

function parseGPX(gpxText) {
  const parser = new DOMParser();
  const xml = parser.parseFromString(gpxText, "application/xml");

  fullRoute = []; fullManeuvers = [];

  // 1) trkpt (track points) -> main polyline
  const trkpts = Array.from(xml.getElementsByTagName("trkpt"));
  for (let pt of trkpts) {
    const lat = parseFloat(pt.getAttribute("lat"));
    const lon = parseFloat(pt.getAttribute("lon"));
    if (!isNaN(lat) && !isNaN(lon)) fullRoute.push({ lat, lon });
  }

  // 2) route points (rtept) often contain named maneuvers (OsmAnd route export)
  const rtepts = Array.from(xml.getElementsByTagName("rtept"));
  for (let pt of rtepts) {
    const lat = parseFloat(pt.getAttribute("lat"));
    const lon = parseFloat(pt.getAttribute("lon"));
    let name = "", desc = "";
    if (pt.getElementsByTagName("name")[0]) name = pt.getElementsByTagName("name")[0].textContent;
    if (pt.getElementsByTagName("desc")[0]) desc = pt.getElementsByTagName("desc")[0].textContent;
    // name often contains instruction (like "turn-left") depending on OsmAnd export; keep lower-case
    fullManeuvers.push({
      lat, lon,
      modifier: (name || 'straight').toLowerCase(),
      name: removeAccent(desc || ''),
      next: ''
    });
  }

  // If trackpoints missing but rtepts exist, use rtepts as route
  if (fullRoute.length === 0 && fullManeuvers.length > 0) {
    fullRoute = fullManeuvers.map(m => ({ lat: m.lat, lon: m.lon }));
  }

  if (fullRoute.length === 0) {
    alert("Kh√¥ng t√¨m th·∫•y t·ªça ƒë·ªô trong GPX");
    return;
  }

  // build routePoints and draw on map
  buildRoutePoints();

  if (routeLine) map.removeLayer(routeLine);
  routeLine = L.polyline(fullRoute.map(p => [p.lat,p.lon]), { color: 'green' }).addTo(map);
  map.fitBounds(routeLine.getBounds());
  log(`‚úÖ ƒê√£ n·∫°p GPX: ${fullRoute.length} ƒëi·ªÉm, ${fullManeuvers.length} b∆∞·ªõc ƒëi·ªÅu h∆∞·ªõng`);
}

/* ====== BLE: scanning / connecting / disconnect handling ====== */
document.getElementById('btnScan').addEventListener('click', async () => {
  try {
    log('üîç ƒêang qu√©t BLE‚Ä¶');
    const device = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: [SERVICE_UUID]
    });
    knownDevices[device.id] = device;
    const opt = new Option(device.name || `Device ${device.id.slice(0,6)}`, device.id);
    document.getElementById('deviceList').appendChild(opt);
    document.getElementById('deviceList').value = device.id;
    log('ƒê√£ th√™m thi·∫øt b·ªã:', device.name || device.id);
  } catch (err) {
    log('L·ªói qu√©t BLE:', err);
  }
});

document.getElementById('btnConnect').addEventListener('click', async () => {
  const id = document.getElementById('deviceList').value;
  const device = knownDevices[id];
  if (!device) return alert('Ch∆∞a ch·ªçn thi·∫øt b·ªã');
  try {
    gattServer = await device.gatt.connect();
    device.addEventListener('gattserverdisconnected', () => {
      log('‚ö†Ô∏è M·∫•t k·∫øt n·ªëi BLE');
      setBLEConnectedUI(false);
      connectedDevice = null; writeChar = null; gattServer = null;
      // show scan/connect again
      document.getElementById('btnScan').style.display = '';
      document.getElementById('btnConnect').style.display = '';
    });
    const service = await gattServer.getPrimaryService(SERVICE_UUID);
    writeChar = await service.getCharacteristic(CHAR_UUID);
    connectedDevice = device;
    setBLEConnectedUI(true);
    // hide scan/connect UI
    document.getElementById('btnScan').style.display = 'none';
    document.getElementById('btnConnect').style.display = 'none';
    log('‚úÖ ƒê√£ k·∫øt n·ªëi BLE:', device.name || device.id);
  } catch (err) {
    log('L·ªói k·∫øt n·ªëi:', err);
  }
});

document.getElementById('btnDisconnect').addEventListener('click', () => {
  if (connectedDevice && connectedDevice.gatt.connected) {
    connectedDevice.gatt.disconnect();
    log('ƒê√£ ng·∫Øt k·∫øt n·ªëi');
  }
});

/* ====== G·ª¨I D·ªÆ LI·ªÜU ‚Äî framing + chunking ====== */
/* ESP32 code c·ªßa b·∫°n hi·ªán ch·ªù m·ªôt JSON array (m·∫£ng) => ch√∫ng ta g·ª≠i m·∫£ng JSON (kh√¥ng b·ªçc object kh√°c)
   V√¨ ESP32 c√≥ callback gom d·ªØ li·ªáu t·ª´ <BEGIN> ... <END> n√™n ta g·ª≠i framed payload.
*/
async function bleWriteChunksStr(str) {
  if (!writeChar) throw 'Ch∆∞a c√≥ characteristic writeChar';
  const enc = new TextEncoder();
  const CHUNK = 180; // safe chunk size (bytes of string)
  for (let i=0;i<str.length;i+=CHUNK) {
    const piece = str.substring(i, i+CHUNK);
    await writeChar.writeValue(enc.encode(piece));
    await new Promise(r=>setTimeout(r, 12)); // short delay to avoid congestion
  }
}

document.getElementById('btnSendRoute').addEventListener('click', async () => {
  if (!writeChar || !connectedDevice) return alert('Ch∆∞a k·∫øt n·ªëi BLE');
  if (!routePoints || routePoints.length === 0) return alert('Ch∆∞a c√≥ tuy·∫øn ƒë·ªÉ g·ª≠i (n·∫°p GPX ho·∫∑c t√≠nh ƒë∆∞·ªùng tr∆∞·ªõc)');

  const progressEl = document.getElementById('progress');
  progressEl.textContent = 'ƒêang g·ª≠i...';

  // Prepare payload: array of objects with exact keys ESP32 expects
  // We intentionally do NOT include the 'dist' field in JSON (ESP32 prior code didn't expect it),
  // but including it is harmless. We'll include lat, lon, action, road, next to match ESP32.
  const payload = routePoints.map(p => ({
    lat: p.lat,
    lon: p.lon,
    action: p.action || 'none',
    road: p.road || '',
    next: p.next || ''
  }));

  const json = JSON.stringify(payload);
  log('üì¶ G·ª≠i framed JSON, bytes:', json.length);

  try {
    // header
    await bleWriteChunksStr('<BEGIN>\n');
    // body JSON
    await bleWriteChunksStr(json);
    // footer
    await bleWriteChunksStr('\n<END>\n');

    progressEl.textContent = 'ƒê√£ g·ª≠i 100%';
    log('üì§ G·ª≠i xong!');
  } catch (e) {
    log('‚ùå G·ª≠i BLE th·∫•t b·∫°i:', e);
    progressEl.textContent = 'G·ª≠i th·∫•t b·∫°i';
  }
});

/* ====== Init ====== */
setBLEConnectedUI(false);
log('Web ready');
</script>
</body>
</html>
