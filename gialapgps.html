<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Chá»‰ Ä‘Æ°á»ng OSM + BLE</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<style>
  #map { height: 80vh; }
  button { margin: 5px; padding: 10px; font-size: 16px; }
</style>
</head>
<body>
<h2>Chá»‰ Ä‘Æ°á»ng OSM + Gá»­i BLE</h2>
<div id="map"></div>
<button onclick="connectBLE()">ğŸ”— Káº¿t ná»‘i ESP32</button>
<button onclick="startSim()">â–¶ Báº¯t Ä‘áº§u giáº£ láº­p di chuyá»ƒn</button>

<script>
let map = L.map('map').setView([10.7769, 106.7009], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19
}).addTo(map);

let start = [10.7769, 106.7009]; // Há»“ ChÃ­ Minh
let end = [10.7870, 106.6980];   // Äiá»ƒm Ä‘áº¿n
let routeCoords = [];
let currentIndex = 0;
let marker = L.marker(start).addTo(map);
let bleServer, bleCharacteristic;

// HÃ m káº¿t ná»‘i BLE
async function connectBLE() {
  try {
    let device = await navigator.bluetooth.requestDevice({
      filters: [{ name: "ESP32" }],
      optionalServices: ["0000ffe0-0000-1000-8000-00805f9b34fb"]
    });
    bleServer = await device.gatt.connect();
    let service = await bleServer.getPrimaryService("0000ffe0-0000-1000-8000-00805f9b34fb");
    bleCharacteristic = await service.getCharacteristic("0000ffe1-0000-1000-8000-00805f9b34fb");
    alert("Káº¿t ná»‘i BLE thÃ nh cÃ´ng!");
  } catch (error) {
    console.error("BLE Error:", error);
  }
}

// HÃ m gá»­i dá»¯ liá»‡u BLE
async function sendBLE(data) {
  if (bleCharacteristic) {
    let encoder = new TextEncoder();
    await bleCharacteristic.writeValue(encoder.encode(data));
    console.log("Gá»­i BLE:", data);
  }
}

// TÃ­nh Ä‘Æ°á»ng tá»« OSM
fetch(`https://router.project-osrm.org/route/v1/driving/${start[1]},${start[0]};${end[1]},${end[0]}?overview=full&geometries=geojson&steps=true`)
  .then(r => r.json())
  .then(data => {
    let coords = data.routes[0].geometry.coordinates;
    routeCoords = coords.map(c => [c[1], c[0]]);
    L.polyline(routeCoords, {color: 'blue'}).addTo(map);
    map.fitBounds(L.polyline(routeCoords).getBounds());
  });

// Giáº£ láº­p di chuyá»ƒn
function startSim() {
  if (routeCoords.length === 0) return;
  currentIndex = 0;
  let simInterval = setInterval(() => {
    if (currentIndex >= routeCoords.length - 1) {
      clearInterval(simInterval);
      console.log("ÄÃ£ Ä‘áº¿n nÆ¡i");
      sendBLE("0m|Äáº¿n nÆ¡i");
      return;
    }
    let pos = routeCoords[currentIndex];
    marker.setLatLng(pos);

    // TÃ­nh khoáº£ng cÃ¡ch Ä‘áº¿n Ä‘iá»ƒm tiáº¿p theo
    let nextPos = routeCoords[currentIndex + 1];
    let dist = getDistance(pos[0], pos[1], nextPos[0], nextPos[1]);
    let direction = getDirection(pos, nextPos);

    sendBLE(`${dist.toFixed(1)}m|${direction}`);
    console.log(`CÃ²n ${dist.toFixed(1)}m -> ${direction}`);

    currentIndex++;
  }, 1000);
}

// HÃ m tÃ­nh khoáº£ng cÃ¡ch giá»¯a 2 tá»a Ä‘á»™
function getDistance(lat1, lon1, lat2, lon2) {
  let R = 6371000; // m
  let dLat = (lat2-lat1) * Math.PI/180;
  let dLon = (lon2-lon1) * Math.PI/180;
  let a = Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(lat1 * Math.PI/180) * Math.cos(lat2 * Math.PI/180) *
          Math.sin(dLon/2) * Math.sin(dLon/2);
  let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// HÃ m xÃ¡c Ä‘á»‹nh hÆ°á»›ng ráº½
function getDirection(p1, p2) {
  let dx = p2[1] - p1[1];
  let dy = p2[0] - p1[0];
  if (Math.abs(dx) > Math.abs(dy)) {
    return dx > 0 ? "Ráº½ pháº£i" : "Ráº½ trÃ¡i";
  } else {
    return dy > 0 ? "Äi tháº³ng" : "Quay láº¡i";
  }
}
</script>
</body>
</html>
