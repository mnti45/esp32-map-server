<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Báº£n Ä‘á»“ OSRM + GPX + BLE</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  #map { height: 80vh; }
  #controls { padding: 10px; background: #f0f0f0; }
  button, input[type=file] { margin: 5px; }
</style>
</head>
<body>

<div id="controls">
  <input type="text" id="start" placeholder="Äiá»ƒm xuáº¥t phÃ¡t"/>
  <input type="text" id="end" placeholder="Äiá»ƒm Ä‘áº¿n"/>
  <button id="btnRoute">ğŸš— TÃ­nh Ä‘Æ°á»ng</button>

  <input type="file" id="gpxFile" accept=".gpx" />
  <button id="btnLoadGPX">ğŸ“‚ Náº¡p GPX</button>
  
  <button id="btnBLE">ğŸ” QuÃ©t & káº¿t ná»‘i ESP32</button>
  <button id="btnSendBLE">ğŸ“¤ Gá»­i dá»¯ liá»‡u cho ESP32</button>
</div>

<div id="map"></div>

<pre id="log" style="padding:10px;background:#eee;height:15vh;overflow:auto;"></pre>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
let map = L.map('map').setView([10.762622, 106.660172], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OSM contributors'
}).addTo(map);

let routeLine = null;
let fullRoute = [];
let fullManeuvers = [];

// BLE vars
let bleDevice = null;
let bleCharacteristic = null;

// BLE UUIDs (cáº§n thay báº±ng UUID ESP32 báº¡n dÃ¹ng)
const SERVICE_UUID = '0000ffe0-0000-1000-8000-00805f9b34fb';
const CHARACTERISTIC_UUID = '0000ffe1-0000-1000-8000-00805f9b34fb';

function log(msg) {
  document.getElementById('log').textContent += msg + "\n";
}

function removeAccent(str) {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

// ====================== OSRM & GPX ======================
document.getElementById('btnRoute').addEventListener('click', async () => {
  if (fullRoute.length > 0) {
    log("ğŸ“‚ Äang dÃ¹ng dá»¯ liá»‡u GPX (khÃ´ng gá»i OSRM)");
    if (routeLine) map.removeLayer(routeLine);
    routeLine = L.polyline(fullRoute.map(p => [p.lat, p.lon]), { color: 'green' }).addTo(map);
    map.fitBounds(routeLine.getBounds());
    return;
  }

  const start = document.getElementById('start').value;
  const end = document.getElementById('end').value;
  if (!start || !end) return alert('Nháº­p Ä‘á»§ Ä‘iá»ƒm xuáº¥t phÃ¡t vÃ  Ä‘iá»ƒm Ä‘áº¿n');

  log("ğŸš— Äang gá»i OSRM Ä‘á»ƒ tÃ­nh Ä‘Æ°á»ng...");
  const url = `https://router.project-osrm.org/route/v1/driving/${start};${end}?overview=full&geometries=geojson&steps=true`;
  const res = await fetch(url);
  const data = await res.json();

  if (data.routes && data.routes.length > 0) {
    const coords = data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
    if (routeLine) map.removeLayer(routeLine);
    routeLine = L.polyline(coords, { color: 'blue' }).addTo(map);
    map.fitBounds(routeLine.getBounds());
    log("âœ… ÄÃ£ váº½ tuyáº¿n Ä‘Æ°á»ng báº±ng OSRM");

    fullManeuvers = [];
    for (let leg of data.routes[0].legs) {
      for (let step of leg.steps) {
        fullManeuvers.push({
          lat: step.maneuver.location[1],
          lon: step.maneuver.location[0],
          modifier: step.maneuver.modifier || '',
          name: removeAccent(step.name || ''),
          next: ''
        });
      }
    }
    log(`ğŸ“œ OSRM Maneuvers: ${fullManeuvers.length} bÆ°á»›c`);
  } else {
    log("âŒ KhÃ´ng tÃ¬m tháº¥y tuyáº¿n Ä‘Æ°á»ng");
  }
});

document.getElementById('btnLoadGPX').addEventListener('click', async () => {
  const fileInput = document.getElementById('gpxFile');
  if (!fileInput.files.length) return alert('Chá»n file GPX trÆ°á»›c');

  const file = fileInput.files[0];
  const text = await file.text();
  parseGPX(text);
});

function parseGPX(gpxText) {
  const parser = new DOMParser();
  const xml = parser.parseFromString(gpxText, "application/xml");

  fullRoute = [];
  fullManeuvers = [];

  const trkpts = xml.getElementsByTagName("trkpt");
  for (let pt of trkpts) {
    const lat = parseFloat(pt.getAttribute("lat"));
    const lon = parseFloat(pt.getAttribute("lon"));
    fullRoute.push({ lat, lon });
  }

  const rtepts = xml.getElementsByTagName("rtept");
  for (let pt of rtepts) {
    const lat = parseFloat(pt.getAttribute("lat"));
    const lon = parseFloat(pt.getAttribute("lon"));
    let name = "";
    let desc = "";
    if (pt.getElementsByTagName("name")[0]) name = pt.getElementsByTagName("name")[0].textContent;
    if (pt.getElementsByTagName("desc")[0]) desc = pt.getElementsByTagName("desc")[0].textContent;

    fullManeuvers.push({
      lat, lon,
      modifier: name || 'straight',
      name: removeAccent(desc || ''),
      next: ''
    });
  }

  if (fullRoute.length === 0 && fullManeuvers.length > 0) {
    fullRoute = fullManeuvers.map(m => ({ lat: m.lat, lon: m.lon }));
  }

  if (fullRoute.length === 0) {
    alert("KhÃ´ng tÃ¬m tháº¥y dá»¯ liá»‡u tá»a Ä‘á»™ trong file GPX");
    return;
  }

  if (routeLine) map.removeLayer(routeLine);
  routeLine = L.polyline(fullRoute.map(p => [p.lat, p.lon]), { color: 'green' }).addTo(map);
  map.fitBounds(routeLine.getBounds());

  log(`âœ… ÄÃ£ náº¡p GPX: ${fullRoute.length} Ä‘iá»ƒm, ${fullManeuvers.length} bÆ°á»›c Ä‘iá»u hÆ°á»›ng`);
}

document.getElementById('start').addEventListener('input', () => { fullRoute = []; });
document.getElementById('end').addEventListener('input', () => { fullRoute = []; });

// ====================== BLE ======================
document.getElementById('btnBLE').addEventListener('click', async () => {
  try {
    log("ğŸ” Äang quÃ©t thiáº¿t bá»‹ BLE...");
    bleDevice = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: [SERVICE_UUID]
    });

    const server = await bleDevice.gatt.connect();
    const service = await server.getPrimaryService(SERVICE_UUID);
    bleCharacteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);

    log(`âœ… ÄÃ£ káº¿t ná»‘i tá»›i: ${bleDevice.name}`);
  } catch (error) {
    log("âŒ Lá»—i BLE: " + error);
  }
});

document.getElementById('btnSendBLE').addEventListener('click', async () => {
  if (!bleCharacteristic) return alert("ChÆ°a káº¿t ná»‘i BLE");

  const data = {
    route: fullRoute,
    maneuvers: fullManeuvers
  };
  const jsonString = JSON.stringify(data);

  try {
    const encoder = new TextEncoder();
    const chunkSize = 200; // BLE packet size limit
    for (let i = 0; i < jsonString.length; i += chunkSize) {
      const chunk = jsonString.substring(i, i + chunkSize);
      await bleCharacteristic.writeValue(encoder.encode(chunk));
    }
    log("ğŸ“¤ ÄÃ£ gá»­i dá»¯ liá»‡u Ä‘iá»u hÆ°á»›ng tá»›i ESP32");
  } catch (error) {
    log("âŒ Gá»­i BLE tháº¥t báº¡i: " + error);
  }
});
</script>
</body>
</html>

