<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <title>OSM Navigation + BLE</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body {
      font-family: Arial;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    #map {
      flex: 1 1 auto;
      height: 50vh;
    }

    #sentDataContainer {
      padding: 6px 10px;
      background: #eef;
      font-size: 12px;
      max-height: 90px;
      overflow: auto;
      border-top: 1px solid #ccc;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    #sentData {
      width: 100%;
      height: 60px;
      font-family: monospace;
      white-space: pre-wrap;
      overflow-wrap: break-word;
      resize: none;
    }

    #copyBtn {
      align-self: flex-end;
      font-size: 11px;
      padding: 4px 8px;
      cursor: pointer;
    }

    #controls {
      padding: 10px;
      background: #f4f4f4;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      border-top: 1px solid #ccc;
      justify-content: space-between;
      flex-shrink: 0;
    }

    #routeSelector {
      padding: 10px;
      background: #f9f9f9;
      border-top: 1px solid #ccc;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      flex-shrink: 0;
      max-height: 110px;
      overflow-x: auto;
      overflow-y: hidden;
    }

    #routeSelector button {
      padding: 6px 12px;
      cursor: pointer;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #eee;
      white-space: nowrap;
      transition: background-color 0.3s, color 0.3s;
    }

    #routeSelector button.selected {
      background: #007bff;
      color: white;
      border-color: #0056b3;
    }

    input[type="text"] {
      padding: 6px;
      width: 260px;
    }

    button {
      padding: 6px 10px;
      cursor: pointer;
      user-select: none;
    }

    #progress {
      color: green;
      font-weight: bold;
      min-width: 100px;
    }

    #progressBar {
      width: 200px;
      height: 12px;
    }
  </style>
</head>
<body>

<div id="map"></div>

<div id="sentDataContainer">
  <strong>D·ªØ li·ªáu ƒë√£ g·ª≠i xu·ªëng ESP32:</strong>
  <textarea id="sentData" readonly></textarea>
  <button id="copyBtn">üìã Copy d·ªØ li·ªáu</button>
</div>

<div id="controls">
  <div>
    <strong>ƒêi·ªÉm ƒë·∫øn:</strong>
    <input id="destInput" type="text" placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ (VD: B·∫øn Th√†nh)" />
    <button id="btnRoute">T√≠nh ƒë∆∞·ªùng</button>
  </div>

  <div>
    <button id="btnScan">üîç Qu√©t BLE</button>
    <select id="deviceList" style="min-width:220px"></select>
    <button id="btnConnect">K·∫øt n·ªëi</button>
    <button id="btnDisconnect">Ng·∫Øt</button>
  </div>

  <div>
    <button id="btnSendRoute">‚¨á G·ª≠i d·ªØ li·ªáu Route</button>
    <span id="progress">Ch∆∞a g·ª≠i</span>
    <progress id="progressBar" value="0" max="100"></progress>
  </div>
</div>

<div id="routeSelector">
  <!-- N√∫t ch·ªçn tuy·∫øn ƒë∆∞·ªùng s·∫Ω ƒë∆∞·ª£c t·∫°o t·∫°i ƒë√¢y -->
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

const map = L.map('map').setView([10.762622, 106.660172], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '¬© OpenStreetMap contributors'
}).addTo(map);

let routeLines = [];
let fullRoute = [], fullManeuvers = [];
let knownDevices = {}, connectedDevice = null, gattServer = null, writeChar = null;
let currentPosition = null; // L∆∞u v·ªã tr√≠ hi·ªán t·∫°i

// Marker cho v·ªã tr√≠ hi·ªán t·∫°i
let userMarker = L.circleMarker([0, 0], {
  radius: 8,
  fillColor: '#007bff',
  color: '#fff',
  weight: 2,
  opacity: 1,
  fillOpacity: 0.8
}).addTo(map).bindPopup('V·ªã tr√≠ hi·ªán t·∫°i');

function log(...args) {
  console.log(...args);
}

// ƒê·ªãnh v·ªã li√™n t·ª•c, c·∫≠p nh·∫≠t marker
function startTrackingPosition() {
  if (!navigator.geolocation) {
    alert('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ƒë·ªãnh v·ªã');
    return;
  }

  navigator.geolocation.watchPosition(pos => {
    currentPosition = { lat: pos.coords.latitude, lon: pos.coords.longitude };
    userMarker.setLatLng([currentPosition.lat, currentPosition.lon]);
    userMarker.bindPopup(`V·ªã tr√≠ hi·ªán t·∫°i<br>Lat: ${currentPosition.lat.toFixed(6)}<br>Lon: ${currentPosition.lon.toFixed(6)}`);
    // map.panTo([currentPosition.lat, currentPosition.lon]); // C√≥ th·ªÉ b·∫≠t n·∫øu mu·ªën t·ª± ƒë·ªông theo d√µi
  }, err => {
    console.warn('L·ªói ƒë·ªãnh v·ªã:', err);
  }, {
    enableHighAccuracy: true,
    maximumAge: 1000,
    timeout: 10000
  });
}

// B·∫Øt ƒë·∫ßu ƒë·ªãnh v·ªã ngay khi load trang
startTrackingPosition();

function removeAccent(str) {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function geocode(q) {
  const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
  const js = await res.json();
  return js.length ? { lat: +js[0].lat, lon: +js[0].lon } : null;
}

// Format th·ªùi gian (gi√¢y -> ph√∫t, gi√¢y)
function formatDuration(seconds) {
  if (seconds < 60) return `${Math.round(seconds)} gi√¢y`;
  const m = Math.floor(seconds / 60);
  const s = Math.round(seconds % 60);
  return s ? `${m} ph√∫t ${s} gi√¢y` : `${m} ph√∫t`;
}

// Format kho·∫£ng c√°ch (m -> km)
function formatDistance(meters) {
  if (meters < 1000) return `${Math.round(meters)} m`;
  return `${(meters / 1000).toFixed(2)} km`;
}

// G·ª≠i BLE (gi·ªØ nguy√™n code c≈©)
document.getElementById('btnScan').addEventListener('click', async () => {
  try {
    const device = await navigator.bluetooth.requestDevice({
      filters: [{ name: 'ESP32-NAV' }],
      optionalServices: [SERVICE_UUID]
    });

    knownDevices[device.id] = device;

    const listEl = document.getElementById('deviceList');
    listEl.innerHTML = '';
    const opt = new Option(device.name || `Device ${device.id.slice(0, 6)}`, device.id);
    listEl.appendChild(opt);
    listEl.value = device.id;

    log('T√¨m th·∫•y ESP32-NAV:', device.name || device.id);
  } catch (err) {
    log('Kh√¥ng t√¨m th·∫•y thi·∫øt b·ªã:', err);
  }
});

document.getElementById('btnConnect').addEventListener('click', async () => {
  const id = document.getElementById('deviceList').value;
  const device = knownDevices[id];
  if (!device) return alert('Ch∆∞a ch·ªçn thi·∫øt b·ªã');
  try {
    gattServer = await device.gatt.connect();
    const service = await gattServer.getPrimaryService(SERVICE_UUID);
    writeChar = await service.getCharacteristic(CHAR_UUID);
    connectedDevice = device;
    alert('K·∫øt n·ªëi th√†nh c√¥ng');
  } catch (err) {
    alert('K·∫øt n·ªëi th·∫•t b·∫°i: ' + err);
  }
});

document.getElementById('btnDisconnect').addEventListener('click', () => {
  if (gattServer) {
    gattServer.disconnect();
    connectedDevice = null;
    writeChar = null;
    alert('ƒê√£ ng·∫Øt k·∫øt n·ªëi');
  }
});

function sleep(ms) {
  return new Promise(r => setTimeout(r, ms));
}

async function sendData(dataStr) {
  if (!writeChar) return alert('Ch∆∞a k·∫øt n·ªëi ESP32');
  const CHUNK_SIZE = 16;
  const encoder = new TextEncoder();
  let offset = 0;
  const bytes = encoder.encode(dataStr);

  while (offset < bytes.length) {
    const chunk = bytes.slice(offset, offset + CHUNK_SIZE);
    await writeChar.writeValue(chunk);
    offset += CHUNK_SIZE;
    let progress = Math.floor((offset / bytes.length) * 100);
    document.getElementById('progressBar').value = progress;
    document.getElementById('progress').textContent = `ƒêang g·ª≠i ${progress}%`;
    await sleep(50);
  }
  document.getElementById('progressBar').value = 100;
  document.getElementById('progress').textContent = 'ƒê√£ g·ª≠i th√†nh c√¥ng!';
  await sleep(1500);
  document.getElementById('progressBar').value = 0;
  document.getElementById('progress').textContent = 'Ch∆∞a g·ª≠i';
}

// Hi·ªÉn th·ªã d·ªØ li·ªáu g·ª≠i xu·ªëng textarea v√† g·ª≠i BLE
function updateSentData() {
  const jsonData = JSON.stringify({ route: fullRoute, maneuvers: fullManeuvers }, null, 2);
  document.getElementById('sentData').value = jsonData;
}

// B·∫•m g·ª≠i route xu·ªëng ESP32
document.getElementById('btnSendRoute').addEventListener('click', async () => {
  if (fullRoute.length === 0) return alert('Ch∆∞a c√≥ tuy·∫øn ƒë∆∞·ªùng ƒë·ªÉ g·ª≠i');
  updateSentData();
  await sendData(document.getElementById('sentData').value);
});

// Copy d·ªØ li·ªáu ƒë√£ g·ª≠i
document.getElementById('copyBtn').addEventListener('click', () => {
  document.getElementById('sentData').select();
  document.execCommand('copy');
  alert('ƒê√£ copy d·ªØ li·ªáu!');
});

// T·∫°o c√°c n√∫t ch·ªçn tuy·∫øn ƒë∆∞·ªùng
const routeSelector = document.getElementById('routeSelector');

function clearRoutes() {
  routeLines.forEach(line => map.removeLayer(line));
  routeLines = [];
  routeSelector.innerHTML = '';
}

function selectRoute(route, polyline, index) {
  routeLines.forEach(line => line.setStyle({ weight: 3, opacity: 0.6 }));
  polyline.setStyle({ weight: 6, opacity: 1 });

  fullRoute = route.geometry.coordinates.map(c => ({ lat: c[1], lon: c[0] }));
  fullManeuvers = (route.legs[0]?.steps || []).map(s => ({
    lat: s.maneuver.location[1],
    lon: s.maneuver.location[0],
    modifier: s.maneuver.modifier || 'straight',
    name: removeAccent(s.name || ''),
    next: removeAccent(s.destinations || '')
  }));

  updateSentData();
  log("ƒê√£ ch·ªçn tuy·∫øn ƒë∆∞·ªùng", index + 1, "v·ªõi", fullRoute.length, "ƒëi·ªÉm");
}

// T√≠nh ƒë∆∞·ªùng v√† hi·ªÉn th·ªã tuy·∫øn v·ªõi l·ª±a ch·ªçn n√∫t
document.getElementById('btnRoute').addEventListener('click', async () => {
  const destText = document.getElementById('destInput').value.trim();
  if (!destText) return alert('Nh·∫≠p ƒë·ªãa ƒëi·ªÉm');
  if (!currentPosition) return alert('Ch∆∞a c√≥ v·ªã tr√≠ hi·ªán t·∫°i');

  const { lat, lon } = currentPosition;
  const dest = await geocode(destText);
  if (!dest) return alert('Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ');

  const url = `https://router.project-osrm.org/route/v1/walking/${lon},${lat};${dest.lon},${dest.lat}?alternatives=true&overview=full&geometries=geojson&steps=true`;
  const res = await fetch(url);
  const data = await res.json();

  if (!data.routes || !data.routes.length) return alert("Kh√¥ng t√¨m ƒë∆∞·ª£c tuy·∫øn ƒë∆∞·ªùng n√†o");

  clearRoutes();

  data.routes.forEach((route, index) => {
    const coords = route.geometry.coordinates.map(c => [c[1], c[0]]);
    const color = index === 0 ? 'blue' : index === 1 ? 'gray' : 'purple';

    const polyline = L.polyline(coords, {
      color,
      weight: index === 0 ? 5 : 3,
      opacity: index === 0 ? 1 : 0.6
    }).addTo(map);

    routeLines.push(polyline);

    const btn = document.createElement('button');
    btn.textContent = `Tuy·∫øn ${index + 1} ‚Äî ${formatDistance(route.distance)} ‚Äî ${formatDuration(route.duration)}`;
    btn.classList.toggle('selected', index === 0);

    btn.addEventListener('click', () => {
      selectRoute(route, polyline, index);
      Array.from(routeSelector.children).forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      map.fitBounds(polyline.getBounds());
    });

    routeSelector.appendChild(btn);

    if (index === 0) {
      selectRoute(route, polyline, index);
      map.fitBounds(polyline.getBounds());
    }
  });
});

</script>
</body>
</html>
