<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>OSM + GPX + BLE (ESP32)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  body { font-family: Arial, sans-serif; margin:0; }
  #map { height: 68vh; }
  #controls { padding: 10px; background:#f5f5f5; display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
  #controls input[type="text"]{ padding:6px 8px; min-width:240px; }
  #controls button { padding:8px 12px; }
  #log { background:#111; color:#0f0; padding:10px; height:22vh; overflow:auto; font-size:13px; }
  #progress { font-weight:600; color:#0a7b0a; }
</style>
</head>
<body>

<div id="controls">
  <strong>ƒêi·ªÉm xu·∫•t ph√°t:</strong>
  <input id="start" type="text" placeholder="VD: 10.77,106.69 ho·∫∑c 'B·∫øn Th√†nh'">
  <strong>ƒêi·ªÉm ƒë·∫øn:</strong>
  <input id="end" type="text" placeholder="VD: 10.80,106.65 ho·∫∑c 'Th·ªß ƒê·ª©c'">
  <button id="btnRoute">üìç T√≠nh ƒë∆∞·ªùng</button>

  <input type="file" id="gpxFile" accept=".gpx">
  <button id="btnLoadGPX">üìÇ N·∫°p GPX (OsmAnd)</button>

  <button id="btnBLE">üîç Qu√©t & k·∫øt n·ªëi ESP32</button>
  <button id="btnSendBLE">üì§ G·ª≠i d·ªØ li·ªáu cho ESP32</button>
  <span id="progress">Ch∆∞a g·ª≠i</span>
</div>

<div id="map"></div>
<pre id="log"></pre>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
/* ====== Leaflet map ====== */
const map = L.map('map').setView([10.762622, 106.660172], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution:'¬© OpenStreetMap' }).addTo(map);

let routeLine = null;
let fullRoute = [];      // [{lat,lon}, ...]
let fullManeuvers = [];  // [{lat,lon,modifier,name,next}, ...]

/* ====== BLE (ESP32 NUS) ====== */
let bleDevice = null, bleServer = null, bleWriteChar = null;
// Tr√πng v·ªõi define tr√™n ESP32 c·ªßa b·∫°n
const SERVICE_UUID        = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
const CHARACTERISTIC_UUID = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";

/* ====== Helpers ====== */
const logEl = document.getElementById('log');
function log(...args){
  const line = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
  logEl.textContent = new Date().toLocaleTimeString() + '  ' + line + "\n" + logEl.textContent;
}
function removeAccent(str){ return (str||'').normalize("NFD").replace(/[\u0300-\u036f]/g, ""); }
function isLatLngPair(text){
  const m = String(text).trim().match(/^\s*(-?\d+(\.\d+)?)[,\s]+(-?\d+(\.\d+)?)\s*$/);
  if(!m) return null;
  const lat = parseFloat(m[1]), lon = parseFloat(m[3]);
  if (isNaN(lat)||isNaN(lon)) return null;
  return {lat, lon};
}
async function geocodeOne(q){
  // N·∫øu user nh·∫≠p ‚Äúlat,lon‚Äù th√¨ kh√¥ng g·ªçi geocode
  const p = isLatLngPair(q);
  if (p) return p;

  const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`;
  const res = await fetch(url);
  const js = await res.json();
  if (!js.length) return null;
  return { lat:+js[0].lat, lon:+js[0].lon };
}

/* Haversine kho·∫£ng c√°ch m√©t */
function distanceMeters(a, b){
  const R=6371000;
  const dLat=(b.lat-a.lat)*Math.PI/180;
  const dLon=(b.lon-a.lon)*Math.PI/180;
  const lat1=a.lat*Math.PI/180;
  const lat2=b.lat*Math.PI/180;
  const u = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
  return 2*R*Math.atan2(Math.sqrt(u), Math.sqrt(1-u));
}

/* match maneuver t·∫°i index route (so kh·ªõp ch√≠nh x√°c to·∫° ƒë·ªô) */
function matchManeuverAt(index){
  const p = fullRoute[index];
  return fullManeuvers.find(m => Math.abs(m.lat - p.lat) < 1e-5 && Math.abs(m.lon - p.lon) < 1e-5);
}

/* t√¨m index b∆∞·ªõc r·∫Ω k·∫ø ti·∫øp t·ª´ m·ªôt ƒëi·ªÉm route */
function findNextManeuverIndex(fromIndex=0){
  for(let i=fromIndex; i<fullRoute.length; i++){
    const m = matchManeuverAt(i);
    if (m && m.modifier !== 'straight') return i;
  }
  return -1;
}

/* ====== GPX PARSER (OsmAnd) ====== */
document.getElementById('btnLoadGPX').addEventListener('click', async () => {
  const f = document.getElementById('gpxFile').files[0];
  if(!f) return alert('Ch·ªçn file GPX tr∆∞·ªõc');
  const text = await f.text();
  parseGPX(text);
});

function parseGPX(gpxText){
  try{
    const xml = new DOMParser().parseFromString(gpxText, "application/xml");

    fullRoute = [];
    fullManeuvers = [];

    // 1) Track points (<trkpt>) cho polyline d√†y
    const trkpts = Array.from(xml.getElementsByTagName("trkpt"));
    trkpts.forEach(pt=>{
      const lat = parseFloat(pt.getAttribute("lat"));
      const lon = parseFloat(pt.getAttribute("lon"));
      if(!isNaN(lat)&&!isNaN(lon)) fullRoute.push({lat,lon});
    });

    // 2) Route points (<rtept>) l√†m ƒëi·ªÉm maneuver; OsmAnd th∆∞·ªùng l∆∞u <name>, <desc>
    const rtepts = Array.from(xml.getElementsByTagName("rtept"));
    rtepts.forEach(pt=>{
      const lat = parseFloat(pt.getAttribute("lat"));
      const lon = parseFloat(pt.getAttribute("lon"));
      let name = pt.getElementsByTagName("name")[0]?.textContent || "";
      let desc = pt.getElementsByTagName("desc")[0]?.textContent || "";
      // M·ªôt s·ªë file OsmAnd d√πng <type> ho·∫∑c extension <osmand:action>‚Ä¶
      let type = pt.getElementsByTagName("type")[0]?.textContent || "";
      const modifier = (name || type || '').toLowerCase() || 'straight';

      fullManeuvers.push({
        lat, lon,
        modifier,
        name: removeAccent(desc || name || ''),
        next: ''
      });
    });

    // N·∫øu kh√¥ng c√≥ trkpt th√¨ d·ª±ng route t·ª´ rtept
    if (fullRoute.length===0 && fullManeuvers.length>0){
      fullRoute = fullManeuvers.map(m=>({lat:m.lat, lon:m.lon}));
    }

    if (fullRoute.length===0){
      alert("Kh√¥ng t√¨m th·∫•y to·∫° ƒë·ªô trong GPX (trkpt/rtept).");
      return;
    }

    // V·∫Ω
    if(routeLine) map.removeLayer(routeLine);
    routeLine = L.polyline(fullRoute.map(p=>[p.lat,p.lon]), {color:'green'}).addTo(map);
    map.fitBounds(routeLine.getBounds());

    log(`‚úÖ GPX n·∫°p: ${fullRoute.length} ƒëi·ªÉm, ${fullManeuvers.length} b∆∞·ªõc maneuver`);
  }catch(e){
    console.error(e);
    alert("L·ªói ƒë·ªçc GPX.");
  }
}

/* ====== OSRM (fallback khi kh√¥ng c√≥ GPX) ====== */
async function computeOSRM(from, to){
  const url = `https://router.project-osrm.org/route/v1/driving/${from.lon},${from.lat};${to.lon},${to.lat}?overview=full&geometries=geojson&steps=true`;
  const res = await fetch(url);
  const data = await res.json();
  if(!data.routes || !data.routes[0]) return null;
  const route = data.routes[0];

  // Tuy·∫øn
  fullRoute = route.geometry.coordinates.map(c => ({lat:c[1], lon:c[0]}));

  // Maneuver
  fullManeuvers = [];
  (route.legs||[]).forEach(leg=>{
    (leg.steps||[]).forEach(s=>{
      fullManeuvers.push({
        lat: s.maneuver.location[1],
        lon: s.maneuver.location[0],
        modifier: (s.maneuver.modifier||'straight'),
        name: removeAccent(s.name||''),
        next: removeAccent(s.destinations||'')
      });
    });
  });

  return route;
}

/* ====== T√≠nh ƒë∆∞·ªùng button ====== */
document.getElementById('btnRoute').addEventListener('click', async ()=>{
  const startText = document.getElementById('start').value.trim();
  const endText   = document.getElementById('end').value.trim();
  if (!startText || !endText) return alert("Nh·∫≠p ƒë·ªß ƒëi·ªÉm xu·∫•t ph√°t & ƒëi·ªÉm ƒë·∫øn.");

  // N·∫øu ƒë√£ c√≥ GPX th√¨ ∆∞u ti√™n GPX (kh√¥ng g·ªçi OSRM)
  if (fullRoute.length > 0){
    if(routeLine) map.removeLayer(routeLine);
    routeLine = L.polyline(fullRoute.map(p=>[p.lat,p.lon]), {color:'green'}).addTo(map);
    map.fitBounds(routeLine.getBounds());
    log("üìÇ ƒêang d√πng d·ªØ li·ªáu GPX ƒë·ªÉ v·∫Ω & g·ª≠i.");
    return;
  }

  // Geocode start/end (h·ªó tr·ª£ nh·∫≠p tr·ª±c ti·∫øp lat,lon)
  const from = await geocodeOne(startText);
  const to   = await geocodeOne(endText);
  if (!from || !to) { alert("Kh√¥ng t√¨m th·∫•y to·∫° ƒë·ªô b·∫Øt ƒë·∫ßu/ƒë√≠ch."); return; }

  log("üöó G·ªçi OSRM (ƒë∆∞·ªùng √¥ t√¥)...");
  const route = await computeOSRM(from, to);
  if (!route) { alert("Kh√¥ng t√≠nh ƒë∆∞·ª£c l·ªô tr√¨nh."); return; }

  if(routeLine) map.removeLayer(routeLine);
  routeLine = L.polyline(fullRoute.map(p=>[p.lat,p.lon]), {color:'blue'}).addTo(map);
  map.fitBounds(routeLine.getBounds());
  log(`‚úÖ OSRM: ${fullRoute.length} ƒëi·ªÉm, ${fullManeuvers.length} maneuver`);
});

/* Khi ng∆∞·ªùi d√πng ch·ªânh input ‚Üí coi nh∆∞ b·ªè GPX hi·ªán t·∫°i ƒë·ªÉ t√≠nh l·∫°i */
document.getElementById('start').addEventListener('input', ()=>{ fullRoute=[]; fullManeuvers=[]; });
document.getElementById('end').addEventListener('input', ()=>{ fullRoute=[]; fullManeuvers=[]; });

/* ====== BLE connect / hide button ====== */
const btnBLE = document.getElementById('btnBLE');
btnBLE.addEventListener('click', async ()=>{
  try{
    log("üîç ƒêang qu√©t thi·∫øt b·ªã BLE...");
    bleDevice = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: [SERVICE_UUID]
    });
    bleDevice.addEventListener('gattserverdisconnected', onBleDisconnected);

    bleServer = await bleDevice.gatt.connect();
    const service = await bleServer.getPrimaryService(SERVICE_UUID);
    bleWriteChar = await service.getCharacteristic(CHARACTERISTIC_UUID);

    log(`‚úÖ ƒê√£ k·∫øt n·ªëi: ${bleDevice.name||bleDevice.id}`);
    // ·∫®n n√∫t khi k·∫øt n·ªëi th√†nh c√¥ng
    btnBLE.style.display = 'none';
  }catch(err){
    log("‚ùå L·ªói BLE: " + err);
  }
});
function onBleDisconnected(){
  log("‚ö†Ô∏è M·∫•t k·∫øt n·ªëi BLE");
  // Hi·ªán l·∫°i n√∫t qu√©t/k·∫øt n·ªëi
  btnBLE.style.display = 'inline-block';
}

/* ====== G·ª≠i d·ªØ li·ªáu xu·ªëng ESP32 ====== */
document.getElementById('btnSendBLE').addEventListener('click', async ()=>{
  if(!bleWriteChar || !bleDevice || !bleDevice.gatt.connected){
    return alert("Ch∆∞a k·∫øt n·ªëi BLE v·ªõi ESP32.");
  }
  if(!fullRoute.length){
    return alert("Ch∆∞a c√≥ d·ªØ li·ªáu l·ªô tr√¨nh (n·∫°p GPX ho·∫∑c b·∫•m T√≠nh ƒë∆∞·ªùng).");
  }

  const progressEl = document.getElementById('progress');
  const enc = new TextEncoder();

  // G·ª≠i theo BATCH ƒëi·ªÉm (gi·ªëng logic tr∆∞·ªõc ƒë√¢y)
  const BATCH_SIZE = 5;
  const total = fullRoute.length;

  for(let i=0; i<total; i+=BATCH_SIZE){
    const batch = [];
    for(let j=i; j<i+BATCH_SIZE && j<total; j++){
      const p = fullRoute[j];
      const m = matchManeuverAt(j);
      const nextTurnIdx = findNextManeuverIndex(j);
      const dist = (nextTurnIdx>j) ? Math.round(distanceMeters(p, fullRoute[nextTurnIdx])) : 0;

      batch.push({
        lat: p.lat,
        lon: p.lon,
        action: m ? m.modifier : 'none',
        road:   m ? m.name     : '',
        next:   m ? m.next     : '',
        dist: dist
      });
    }
    const msg = JSON.stringify(batch);

    // Chia nh·ªè JSON n·∫øu c·∫ßn (gi·ªõi h·∫°n g√≥i BLE)
    const PACKET = 180; // an to√†n cho nhi·ªÅu tr√¨nh duy·ªát/stack
    for (let k=0; k<msg.length; k+=PACKET){
      const chunk = msg.substring(k, k+PACKET);
      await bleWriteChar.writeValue(enc.encode(chunk));
      await new Promise(r=>setTimeout(r, 50)); // nh·∫£ b·ªõt ƒë·ªÉ tr√°nh overflow
    }

    const sent = Math.min(i+BATCH_SIZE, total);
    progressEl.textContent = `ƒê√£ g·ª≠i ${sent}/${total} (${Math.round(sent/total*100)}%)`;
    await new Promise(r=>setTimeout(r, 100));
  }
  log('üì§ ƒê√£ g·ª≠i to√†n b·ªô d·ªØ li·ªáu route (batch)');
  progressEl.textContent = 'Ho√†n t·∫•t!';
});
</script>
</body>
</html>
