<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <title>OSM Navigation + BLE</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body {
      font-family: Arial;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    #log {
      display: none; /* ·∫®n log n·∫øu kh√¥ng c·∫ßn */
    }

    #map {
      flex: 1;
      height: 100%;
    }

    #controls {
      padding: 10px;
      background: #f4f4f4;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      border-top: 1px solid #ccc;
      justify-content: space-between;
    }

    input[type="text"] {
      padding: 6px;
      width: 260px;
    }

    button {
      padding: 6px 10px;
    }

    #progress {
      color: green;
      font-weight: bold;
    }

    #progressBar {
      width: 200px;
      height: 12px;
    }

    #sentDataContainer {
      padding: 6px 10px;
      background: #eef;
      font-size: 12px;
      max-height: 90px;
      overflow: auto;
      border-top: 1px solid #ccc;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    #sentData {
      width: 100%;
      height: 60px;
      font-family: monospace;
      white-space: pre-wrap;
      overflow-wrap: break-word;
      resize: none;
    }

    #copyBtn {
      align-self: flex-end;
      font-size: 11px;
    }
  </style>
</head>
<body>

<div id="map"></div>

<div id="sentDataContainer">
  <strong>D·ªØ li·ªáu ƒë√£ g·ª≠i xu·ªëng ESP32:</strong>
  <textarea id="sentData" readonly></textarea>
  <button id="copyBtn">üìã Copy d·ªØ li·ªáu</button>
</div>

<div id="controls">
  <div>
    <strong>ƒêi·ªÉm ƒë·∫øn:</strong>
    <input id="destInput" type="text" placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ (VD: B·∫øn Th√†nh)" />
    <button id="btnRoute">T√≠nh ƒë∆∞·ªùng</button>
  </div>

  <div>
    <button id="btnScan">üîç Qu√©t BLE</button>
    <select id="deviceList" style="min-width:220px"></select>
    <button id="btnConnect">K·∫øt n·ªëi</button>
    <button id="btnDisconnect">Ng·∫Øt</button>
  </div>

  <div>
    <button id="btnSendRoute">‚¨á G·ª≠i d·ªØ li·ªáu Route</button>
    <span id="progress">Ch∆∞a g·ª≠i</span>
    <progress id="progressBar" value="0" max="100"></progress>
  </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

const map = L.map('map').setView([10.762622, 106.660172], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '¬© OpenStreetMap contributors'
}).addTo(map);

// ‚úÖ ƒê·ªãnh v·ªã li√™n t·ª•c + ch√≠nh x√°c
let currentPosition = null;
let userMarker = null;

navigator.geolocation.watchPosition(
  (pos) => {
    const lat = pos.coords.latitude;
    const lon = pos.coords.longitude;

    currentPosition = { lat, lon };

    if (!userMarker) {
      userMarker = L.marker([lat, lon], {
        title: "V·ªã tr√≠ hi·ªán t·∫°i",
        icon: L.icon({
          iconUrl: "https://maps.gstatic.com/mapfiles/ms2/micons/blue-dot.png",
          iconSize: [24, 24],
          iconAnchor: [12, 12]
        })
      }).addTo(map);
      map.setView([lat, lon], 17); // Zoom ƒë·∫øn v·ªã tr√≠ ƒë·∫ßu
    } else {
      userMarker.setLatLng([lat, lon]);
    }

    // üëâ N·∫øu mu·ªën b·∫£n ƒë·ªì lu√¥n theo d√µi b·∫°n: b·ªè d·∫•u //
    // map.panTo([lat, lon], { animate: true });
  },
  (err) => {
    console.error("Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠:", err);
    alert("‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠. H√£y b·∫≠t GPS v√† c·∫•p quy·ªÅn ƒë·ªãnh v·ªã cho tr√¨nh duy·ªát.");
  },
  {
    enableHighAccuracy: true,
    maximumAge: 0,
    timeout: 10000
  }
);

let routeLine = null;
let knownDevices = {}, connectedDevice = null, gattServer = null, writeChar = null;
let fullRoute = [], fullManeuvers = [];

function log(...args) {
  console.log(...args);
}

// ... (gi·ªØ nguy√™n to√†n b·ªô c√°c ph·∫ßn c√≤n l·∫°i nh∆∞ `btnScan`, `btnConnect`, `btnRoute`, `btnSendRoute`, v.v.) ...


document.getElementById('btnScan').addEventListener('click', async () => {
  try {
    const device = await navigator.bluetooth.requestDevice({
      filters: [{ name: 'ESP32-NAV' }],
      optionalServices: [SERVICE_UUID]
    });

    knownDevices[device.id] = device;

    const listEl = document.getElementById('deviceList');
    listEl.innerHTML = '';
    const opt = new Option(device.name || `Device ${device.id.slice(0, 6)}`, device.id);
    listEl.appendChild(opt);
    listEl.value = device.id;

    log('T√¨m th·∫•y ESP32-NAV:', device.name || device.id);
  } catch (err) {
    log('Kh√¥ng t√¨m th·∫•y thi·∫øt b·ªã:', err);
  }
});

document.getElementById('btnConnect').addEventListener('click', async () => {
  const id = document.getElementById('deviceList').value;
  const device = knownDevices[id];
  if (!device) return alert('Ch∆∞a ch·ªçn thi·∫øt b·ªã');
  try {
    gattServer = await device.gatt.connect();
    const service = await gattServer.getPrimaryService(SERVICE_UUID);
    writeChar = await service.getCharacteristic(CHAR_UUID);
    connectedDevice = device;
    log('ƒê√£ k·∫øt n·ªëi BLE');
  } catch (err) {
    log('L·ªói k·∫øt n·ªëi:', err);
  }
});

document.getElementById('btnDisconnect').addEventListener('click', () => {
  if (connectedDevice && connectedDevice.gatt.connected) {
    connectedDevice.gatt.disconnect();
    log('ƒê√£ ng·∫Øt k·∫øt n·ªëi');
  }
});

function removeAccent(str) {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function geocode(q) {
  const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
  const js = await res.json();
  return js.length ? { lat: +js[0].lat, lon: +js[0].lon } : null;
}

async function computeRoute(lat0, lon0, lat1, lon1) {
  const url = `https://router.project-osrm.org/route/v1/walking/${lon0},${lat0};${lon1},${lat1}?overview=full&geometries=geojson&steps=true`;
  const res = await fetch(url);
  const data = await res.json();
  return data.routes[0];
}

function calculateDistance(a, b) {
  const R = 6371000;
  const dLat = (b.lat - a.lat) * Math.PI / 180;
  const dLon = (b.lon - a.lon) * Math.PI / 180;
  const lat1 = a.lat * Math.PI / 180;
  const lat2 = b.lat * Math.PI / 180;
  const ua = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(ua), Math.sqrt(1 - ua));
  return R * c;
}

function findNextManeuverIndex(fromIndex = 0) {
  for (let i = fromIndex; i < fullRoute.length; i++) {
    const match = matchManeuverAt(i);
    if (match && match.modifier !== 'straight') return i;
  }
  return -1;
}

function matchManeuverAt(index) {
  const p = fullRoute[index];
  return fullManeuvers.find(m =>
    Math.abs(m.lat - p.lat) < 1e-5 && Math.abs(m.lon - p.lon) < 1e-5
  );
}

document.getElementById('btnRoute').addEventListener('click', async () => {
  const destText = document.getElementById('destInput').value.trim();
  if (!destText) return alert('Nh·∫≠p ƒë·ªãa ƒëi·ªÉm');

  const pos = await new Promise((res, rej) =>
    navigator.geolocation.getCurrentPosition(res, rej, {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    })
  );

  const { latitude, longitude } = pos.coords;
  const dest = await geocode(destText);
  if (!dest) return alert('Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ n√†y');

  const route = await computeRoute(latitude, longitude, dest.lat, dest.lon);
  if (!route) return alert('Kh√¥ng t√≠nh ƒë∆∞·ª£c l·ªô tr√¨nh');

  fullRoute = route.geometry.coordinates.map(c => ({ lat: c[1], lon: c[0] }));
  fullManeuvers = (route.legs[0]?.steps || []).map(s => ({
    lat: s.maneuver.location[1],
    lon: s.maneuver.location[0],
    modifier: s.maneuver.modifier || 'straight',
    name: removeAccent(s.name || ''),
    next: removeAccent(s.destinations || '')
  }));

  if (routeLine) map.removeLayer(routeLine);
  routeLine = L.polyline(fullRoute.map(p => [p.lat, p.lon]), { color: 'blue' }).addTo(map);
  map.fitBounds(routeLine.getBounds());
  log('T√≠nh ƒë∆∞·ªùng xong:', fullRoute.length, 't·ªça ƒë·ªô -', fullManeuvers.length, 'maneuver');
});

document.getElementById('btnSendRoute').addEventListener('click', async () => {
  if (!writeChar || !connectedDevice) return alert('Ch∆∞a k·∫øt n·ªëi BLE');

  const pos = await new Promise((res, rej) =>
    navigator.geolocation.getCurrentPosition(res, rej, {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    })
  );

  const { latitude, longitude } = pos.coords;

  const payload = {
    start: { lat: latitude, lon: longitude },
    route: []
  };

  for (let j = 0; j < fullRoute.length; j++) {
    const p = fullRoute[j];
    const m = matchManeuverAt(j);
    const nextTurnIdx = findNextManeuverIndex(j);
    const dist = nextTurnIdx > j ? Math.round(calculateDistance(p, fullRoute[nextTurnIdx])) : 0;

    payload.route.push({
      lat: p.lat,
      lon: p.lon,
      action: m ? m.modifier : 'none',
      road: m ? m.name : '',
      next: m ? m.next : '',
      dist: dist
    });
  }

  const enc = new TextEncoder();
  const jsonStr = JSON.stringify(payload);
  const data = enc.encode(jsonStr);
  const CHUNK_SIZE = 100;

  for (let i = 0; i < data.length; i += CHUNK_SIZE) {
    const chunk = data.slice(i, i + CHUNK_SIZE);
    await writeChar.writeValue(chunk);
    await new Promise(resolve => setTimeout(resolve, 30));

    const percent = Math.min(100, Math.round((i + CHUNK_SIZE) * 100 / data.length));
    document.getElementById('progress').innerText = `ƒê√£ g·ª≠i ${percent}%`;
    document.getElementById('progressBar').value = percent;
  }

  await writeChar.writeValue(enc.encode('###END###'));

  document.getElementById('sentData').value = jsonStr;
  document.getElementById('progress').innerText = "‚úÖ ƒê√£ g·ª≠i xong";
  document.getElementById('progressBar').value = 100;
  log("ƒê√£ g·ª≠i to√†n b·ªô route + v·ªã tr√≠");
});

// Copy data
document.getElementById('copyBtn').addEventListener('click', async () => {
  const txt = document.getElementById('sentData').value;
  await navigator.clipboard.writeText(txt);
  alert("‚úÖ ƒê√£ copy d·ªØ li·ªáu!");
});
</script>
</body>
</html>

