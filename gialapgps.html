<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <title>OSM Navigation + BLE</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #sentDataContainer {
      padding: 8px 12px;
      background: #eef6ff;
      font-size: 12px;
      max-height: 120px;
      overflow: auto;
      border-bottom: 1px solid #ccc;
      flex-shrink: 0;
    }
    #sentData {
      width: 100%;
      height: 80px;
      font-family: monospace;
      white-space: pre-wrap;
      overflow-wrap: break-word;
      resize: none;
    }
    #copyBtn {
      margin-top: 6px;
      font-size: 12px;
      padding: 4px 8px;
      cursor: pointer;
    }
    #map {
      flex: 1 1 auto;
      height: auto;
      min-height: 400px;
    }
    #controls {
      padding: 12px 10px;
      background: #f9f9f9;
      border-top: 1px solid #ccc;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    #controls > div {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    input[type="text"] {
      padding: 6px 8px;
      width: 250px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    select {
      padding: 6px 8px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #ccc;
      min-width: 220px;
    }
    button {
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #007bff;
      background: #007bff;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:hover {
      background: #0056b3;
    }
    #progress {
      font-weight: 600;
      color: green;
      min-width: 130px;
      text-align: center;
    }
    progress {
      width: 200px;
      height: 14px;
      border-radius: 6px;
      overflow: hidden;
    }
  </style>
</head>
<body>

<div id="sentDataContainer">
  <strong>D·ªØ li·ªáu ƒë√£ g·ª≠i xu·ªëng ESP32:</strong>
  <textarea id="sentData" readonly></textarea>
  <button id="copyBtn">üìã Copy d·ªØ li·ªáu</button>
</div>

<div id="map"></div>

<div id="controls">
  <div>
    <strong>ƒêi·ªÉm ƒë·∫øn:</strong>
    <input id="destInput" type="text" placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ (VD: B·∫øn Th√†nh)" />
    <button id="btnRoute">T√≠nh ƒë∆∞·ªùng</button>
  </div>

  <div>
    <button id="btnScan">üîç Qu√©t BLE</button>
    <select id="deviceList" style="min-width:220px"></select>
    <button id="btnConnect">K·∫øt n·ªëi</button>
    <button id="btnDisconnect">Ng·∫Øt</button>
  </div>

  <div>
    <strong>Tuy·∫øn ƒë∆∞·ªùng:</strong>
    <select id="routeSelect" style="min-width:240px"></select>
  </div>

  <div>
    <button id="btnSendRoute">‚¨á G·ª≠i d·ªØ li·ªáu Route</button>
    <span id="progress">Ch∆∞a g·ª≠i</span>
    <progress id="progressBar" value="0" max="100"></progress>
  </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
// --- BLE UUIDs ---
const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

// Bi·∫øn qu·∫£n l√Ω BLE
let knownDevices = {};
let connectedDevice = null;
let gattServer = null;
let writeChar = null;

// Bi·∫øn qu·∫£n l√Ω b·∫£n ƒë·ªì, route
let map, currentPositionMarker = null, routeLayer = null;
let routesData = [];
let fullRoute = [];

// --- Kh·ªüi t·∫°o b·∫£n ƒë·ªì Leaflet ---
function initMap() {
  map = L.map('map').setView([10.7769, 106.7009], 13); // trung t√¢m TP.HCM l√†m m·∫∑c ƒë·ªãnh

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
  }).addTo(map);

  // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(pos => {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      currentPositionMarker = L.marker([lat, lon]).addTo(map).bindPopup("V·ªã tr√≠ hi·ªán t·∫°i").openPopup();
      map.setView([lat, lon], 14);
    }, err => {
      alert("Kh√¥ng l·∫•y ƒë∆∞·ª£c v·ªã tr√≠ hi·ªán t·∫°i: " + err.message);
    });
  } else {
    alert("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Geolocation");
  }
}

// --- X√≥a tuy·∫øn ƒë∆∞·ªùng c≈© ---
function clearRoutes() {
  if (routeLayer) {
    map.removeLayer(routeLayer);
    routeLayer = null;
  }
}

// --- Hi·ªÉn th·ªã tuy·∫øn ƒë√£ ch·ªçn ---
function selectRoute(index) {
  clearRoutes();
  if (!routesData || !routesData[index]) return;

  const route = routesData[index];
  routeLayer = L.geoJSON(route.geometry, {
    style: { color: 'blue', weight: 5 }
  }).addTo(map);

  // Zoom t·ªõi tuy·∫øn ƒë∆∞·ªùng
  map.fitBounds(routeLayer.getBounds());

  // L∆∞u d·ªØ li·ªáu route ƒë·ªÉ g·ª≠i BLE (chuy·ªÉn geojson coords sang [{lat, lon}])
  fullRoute = route.geometry.coordinates.map(coord => ({
  lat: coord[1],
  lon: coord[0],
  action: "none",
  road: "Unknown",
  next: ""
}));

}

// --- H√†m g·ªçi API ƒë·ªãnh tuy·∫øn OSRM ---
async function computeRoute(startLat, startLon, endLat, endLon) {
  const url = `https://router.project-osrm.org/route/v1/driving/${startLon},${startLat};${endLon},${endLat}?overview=full&geometries=geojson`;
  try {
    const response = await fetch(url);
    const data = await response.json();
    if (data.code !== 'Ok' || !data.routes.length) return [];

    return data.routes.map(route => ({
      geometry: route.geometry,
      distance: route.distance,
      duration: route.duration
    }));
  } catch (e) {
    console.error('L·ªói l·∫•y tuy·∫øn:', e);
    return [];
  }
}

// --- H√†m geocode ƒë∆°n gi·∫£n qua Nominatim ---
async function geocode(address) {
  const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`;
  try {
    const res = await fetch(url);
    const data = await res.json();
    if (!data.length) return null;
    return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon) };
  } catch {
    return null;
  }
}

// --- BLE x·ª≠ l√Ω ng·∫Øt k·∫øt n·ªëi t·ª± ƒë·ªông ---
function onDisconnected(event) {
  alert('Thi·∫øt b·ªã ƒë√£ ng·∫Øt k·∫øt n·ªëi');
  connectedDevice = null;
  writeChar = null;
  gattServer = null;
  updateDeviceList();
}

// --- Qu√©t BLE ---
async function scanBLE() {
  try {
    const device = await navigator.bluetooth.requestDevice({
      filters: [{ name: 'ESP32-NAV' }],
      optionalServices: [SERVICE_UUID]
    });
    device.addEventListener('gattserverdisconnected', onDisconnected);
    knownDevices[device.id] = device;
    updateDeviceList();
  } catch (error) {
    console.error('Qu√©t thi·∫øt b·ªã BLE l·ªói:', error);
    alert('Qu√©t BLE th·∫•t b·∫°i: ' + error.message);
  }
}

// --- C·∫≠p nh·∫≠t danh s√°ch thi·∫øt b·ªã ---
function updateDeviceList() {
  const select = document.getElementById('deviceList');
  select.innerHTML = '';
  for (const id in knownDevices) {
    const dev = knownDevices[id];
    const option = document.createElement('option');
    option.value = id;
    option.text = dev.name || dev.id;
    select.appendChild(option);
  }
}

// --- K·∫øt n·ªëi BLE ---
async function connectBLE() {
  const select = document.getElementById('deviceList');
  const deviceId = select.value;
  if (!deviceId) {
    alert('Vui l√≤ng ch·ªçn thi·∫øt b·ªã ƒë·ªÉ k·∫øt n·ªëi');
    return;
  }
  const device = knownDevices[deviceId];
  if (!device) {
    alert('Thi·∫øt b·ªã kh√¥ng t·ªìn t·∫°i');
    return;
  }

  try {
    gattServer = await device.gatt.connect();
    gattServer.device.addEventListener('gattserverdisconnected', onDisconnected);
    const service = await gattServer.getPrimaryService(SERVICE_UUID);
    writeChar = await service.getCharacteristic(CHAR_UUID);
    connectedDevice = device;
    alert(`ƒê√£ k·∫øt n·ªëi v·ªõi ${device.name || device.id}`);
  } catch (e) {
    alert('L·ªói k·∫øt n·ªëi BLE: ' + e.message);
  }
}

// --- Ng·∫Øt k·∫øt n·ªëi BLE ---
function disconnectBLE() {
  if (gattServer && gattServer.connected) {
    gattServer.disconnect();
    alert('ƒê√£ ng·∫Øt k·∫øt n·ªëi BLE');
  }
  connectedDevice = null;
  writeChar = null;
  gattServer = null;
  updateDeviceList();
}

// --- G·ª≠i d·ªØ li·ªáu route qua BLE ---
// G·ª≠i d·ªØ li·ªáu theo chunk 20 bytes, th√™m delay 50ms ƒë·ªÉ tr√°nh b·ªã m·∫•t g√≥i
async function sendRouteData() {
  if (!writeChar || !fullRoute.length || !currentPositionMarker) {
    alert('Ch∆∞a k·∫øt n·ªëi BLE ho·∫∑c ch∆∞a c√≥ d·ªØ li·ªáu tuy·∫øn ƒë∆∞·ªùng ho·∫∑c v·ªã tr√≠ hi·ªán t·∫°i!');
    return;
  }

  const start = {
    lat: currentPositionMarker.getLatLng().lat,
    lon: currentPositionMarker.getLatLng().lng
  };
  const payload = {
  start: {
    lat: currentPositionMarker.getLatLng().lat,
    lon: currentPositionMarker.getLatLng().lng
  },
  route: fullRoute
};
const jsonString = JSON.stringify(payload);

  console.log('D·ªØ li·ªáu g·ª≠i:', jsonString);

  document.getElementById('sentData').value = jsonString;

  const encoder = new TextEncoder();
  const encoded = encoder.encode(jsonString);

  const CHUNK_SIZE = 20;
  const endSignal = encoder.encode("###END###");
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progress');

  progressBar.value = 0;
  progressBar.max = encoded.length + endSignal.length;
  progressText.textContent = 'ƒêang g·ª≠i...';

  // H√†m delay ƒë∆°n gi·∫£n
  const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

  try {
    let offset = 0;
    while (offset < encoded.length) {
      const chunk = encoded.slice(offset, offset + CHUNK_SIZE);
      await writeChar.writeValue(chunk);
      offset += chunk.length;
      progressBar.value = offset;
      await delay(50);
    }

    // G·ª≠i endSignal c≈©ng chia chunk nh·ªè
    let endOffset = 0;
    while (endOffset < endSignal.length) {
      const chunk = endSignal.slice(endOffset, endOffset + CHUNK_SIZE);
      await writeChar.writeValue(chunk);
      endOffset += chunk.length;
      progressBar.value = offset + endOffset;
      await delay(50);
    }

    progressText.textContent = 'G·ª≠i th√†nh c√¥ng!';
  } catch (e) {
    console.error('L·ªói g·ª≠i d·ªØ li·ªáu:', e);
    progressText.textContent = 'L·ªói g·ª≠i!';
    alert('L·ªói g·ª≠i d·ªØ li·ªáu: ' + e.message);
  }
}

// --- COPY D·ªØ li·ªáu ƒë√£ g·ª≠i ---
document.getElementById('copyBtn').addEventListener('click', () => {
  const sentData = document.getElementById('sentData');
  sentData.select();
  document.execCommand('copy');
  alert('ƒê√£ copy d·ªØ li·ªáu!');
});

// --- N√∫t t√≠nh ƒë∆∞·ªùng ---
document.getElementById('btnRoute').addEventListener('click', async () => {
  const destText = document.getElementById('destInput').value.trim();
  if (!destText) {
    alert('Vui l√≤ng nh·∫≠p ƒëi·ªÉm ƒë·∫øn!');
    return;
  }
  if (!currentPositionMarker) {
    alert('Kh√¥ng c√≥ v·ªã tr√≠ hi·ªán t·∫°i!');
    return;
  }

  const destCoord = await geocode(destText);
  if (!destCoord) {
    alert('Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ!');
    return;
  }

  const startLat = currentPositionMarker.getLatLng().lat;
  const startLon = currentPositionMarker.getLatLng().lng;

  const computedRoutes = await computeRoute(startLat, startLon, destCoord.lat, destCoord.lon);
  if (!computedRoutes.length) {
    alert('Kh√¥ng t√¨m th·∫•y tuy·∫øn ƒë∆∞·ªùng!');
    return;
  }

  routesData = computedRoutes;

  clearRoutes();

  const select = document.getElementById('routeSelect');
  select.innerHTML = '';
  routesData.forEach((r, i) => {
    const option = document.createElement('option');
    option.value = i;
    option.text = `Tuy·∫øn ${i + 1}: ${Math.round(r.distance / 1000)} km - ${Math.round(r.duration / 60)} ph√∫t`;
    select.appendChild(option);
  });

  selectRoute(0);
});

// --- Ch·ªçn tuy·∫øn ƒë∆∞·ªùng ---
document.getElementById('routeSelect').addEventListener('change', e => {
  const idx = Number(e.target.value);
  selectRoute(idx);
});

// --- N√∫t qu√©t, k·∫øt n·ªëi, ng·∫Øt ---
document.getElementById('btnScan').addEventListener('click', scanBLE);
document.getElementById('btnConnect').addEventListener('click', connectBLE);
document.getElementById('btnDisconnect').addEventListener('click', disconnectBLE);

// --- N√∫t g·ª≠i d·ªØ li·ªáu ---
document.getElementById('btnSendRoute').addEventListener('click', sendRouteData);

// --- Kh·ªüi t·∫°o b·∫£n ƒë·ªì khi load trang ---
window.onload = initMap;
</script>
</body>
</html>


