<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<title>GPX ‚Üí Binary BLE Sender</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  body { font-family: Arial; margin: 12px; }
  #controls { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
  button, input[type=file], select, input[type=text] { padding:8px; }
  #log { margin-top:12px; background:#111; color:#0f0; padding:12px; height:240px; overflow:auto; white-space:pre-wrap; font-family:monospace; }
</style>
</head>
<body>
<h3>Upload GPX ‚Üí Encode Binary ‚Üí Send via BLE</h3>

<div id="controls">
  <input type="file" id="gpxFile" accept=".gpx" />
  <button id="btnLoadGPX">N·∫°p GPX</button>

  <button id="btnScan">üîç Qu√©t BLE</button>
  <select id="deviceList" style="min-width:220px"></select>
  <button id="btnConnect">K·∫øt n·ªëi</button>
  <button id="btnDisconnect">Ng·∫Øt</button>

  <button id="btnSend">‚¨á G·ª≠i Binary</button>
  <span id="status">Ch∆∞a k·∫øt n·ªëi</span>
</div>

<div id="log"></div>

<script>
const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const CHAR_UUID    = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

const logEl = document.getElementById('log');
function log(...args) {
  const ts = new Date().toLocaleTimeString();
  logEl.textContent = ts + '  ' + args.join(' ') + '\n' + logEl.textContent;
}

let devices = {}, selectedDevice = null, gattServer = null, writeChar = null;
let parsedPoints = []; // [{lat,lon,action,road,next}]
let roadsList = [], nextsList = [], actionMap = {};
let encodedBuffer = null;

document.getElementById('btnLoadGPX').addEventListener('click', async () => {
  const f = document.getElementById('gpxFile').files[0];
  if (!f) return alert('Ch·ªçn file GPX tr∆∞·ªõc');
  const txt = await f.text();
  parseGPX(txt);
});

function parseGPX(gpxText) {
  parsedPoints = [];
  roadsList = [];
  nextsList = [];
  actionMap = {}; // action string -> id

  const parser = new DOMParser();
  const xml = parser.parseFromString(gpxText, "application/xml");

  // Prefer <rtept> for maneuvers if present, else use <trkpt> as polyline points without action
  const rtepts = Array.from(xml.getElementsByTagName('rtept'));
  const trkpts = Array.from(xml.getElementsByTagName('trkpt'));
  // We'll produce points from trkpts (route polyline) and use rtepts as maneuver hints.
  // Build maneuver map keyed by lat,lon string
  const maneuverMap = new Map();
  for (let r of rtepts) {
    const lat = parseFloat(r.getAttribute('lat'));
    const lon = parseFloat(r.getAttribute('lon'));
    let name = r.getElementsByTagName('name')[0]?.textContent || '';
    let desc = r.getElementsByTagName('desc')[0]?.textContent || '';
    const key = lat.toFixed(6) + ',' + lon.toFixed(6);
    maneuverMap.set(key, { name: (desc || name), action: name || 'straight', next: '' });
    // add to lists
    if (name && !roadsList.includes(name)) roadsList.push(name);
    if (desc && !nextsList.includes(desc)) nextsList.push(desc);
  }

  // Action mapping standard set (extend as needed)
  const knownActions = ['none','straight','left','right','slight left','slight right','uturn'];
  knownActions.forEach((a,i)=>actionMap[a]=i);

  // Parse track points (trkpt) into parsedPoints
  if (trkpts.length > 0) {
    for (let i=0;i<trkpts.length;i++) {
      const pt = trkpts[i];
      const lat = parseFloat(pt.getAttribute('lat'));
      const lon = parseFloat(pt.getAttribute('lon'));
      const key = lat.toFixed(6) + ',' + lon.toFixed(6);
      let action = 'none', road = '', next = '';
      if (maneuverMap.has(key)) {
        const m = maneuverMap.get(key);
        action = (m.action || 'straight').toLowerCase();
        road = m.name || '';
        next = m.next || '';
        if (road && !roadsList.includes(road)) roadsList.push(road);
        if (next && !nextsList.includes(next)) nextsList.push(next);
        if (!(action in actionMap)) {
          const id = Object.keys(actionMap).length;
          actionMap[action] = id;
        }
      }
      parsedPoints.push({ lat, lon, action, road, next });
    }
  } else {
    // fallback: if no trkpts but rtepts exist, use them
    for (let r of rtepts) {
      const lat = parseFloat(r.getAttribute('lat'));
      const lon = parseFloat(r.getAttribute('lon'));
      const name = r.getElementsByTagName('name')[0]?.textContent || '';
      const desc = r.getElementsByTagName('desc')[0]?.textContent || '';
      let action = (name || 'straight').toLowerCase();
      if (!(action in actionMap)) actionMap[action] = Object.keys(actionMap).length;
      if (name && !roadsList.includes(name)) roadsList.push(name);
      if (desc && !nextsList.includes(desc)) nextsList.push(desc);
      parsedPoints.push({ lat, lon, action, road: desc||name, next: '' });
    }
  }

  log(`Parsed points: ${parsedPoints.length}  roads:${roadsList.length} nexts:${nextsList.length} actions:${Object.keys(actionMap).length}`);
  // prepare binary (but not encoded yet)
  encodedBuffer = null;
}

function buildBinary() {
  if (!parsedPoints || parsedPoints.length===0) return null;

  // ensure counts fit in uint8 for point references (road/next indices)
  if (roadsList.length > 255 || nextsList.length > 255) {
    alert('Too many distinct road/next strings (>255). Please simplify GPX or use smaller dataset.');
    return null;
  }
  const pointCount = parsedPoints.length;
  const roadCount = roadsList.length;
  const nextCount = nextsList.length;
  const actionCount = Object.keys(actionMap).length;

  // encode roads and nexts lengths
  let roadsBytes = 0;
  const roadsEncoded = roadsList.map(s => {
    const bytes = new TextEncoder().encode(s || '');
    roadsBytes += 1 + bytes.length;
    return bytes;
  });
  let nextsBytes = 0;
  const nextsEncoded = nextsList.map(s => {
    const bytes = new TextEncoder().encode(s || '');
    nextsBytes += 1 + bytes.length;
    return bytes;
  });

  const headerSize = 12; // magic(4)+version(1)+res3+payloadLen(4)
  // payload: pointCount(4)+roadCount(2)+nextCount(2) + roadsBytes + nextsBytes + (pointCount*12)
  const payloadSize = 4 + 2 + 2 + roadsBytes + nextsBytes + (pointCount * 12);
  const totalSize = headerSize + payloadSize;

  const buf = new ArrayBuffer(totalSize);
  const view = new DataView(buf);
  let offs = 0;
  // Header
  view.setUint8(offs++, 'G'.charCodeAt(0));
  view.setUint8(offs++, 'P'.charCodeAt(0));
  view.setUint8(offs++, 'X'.charCodeAt(0));
  view.setUint8(offs++, 'B'.charCodeAt(0));
  view.setUint8(offs++, 1); // version
  view.setUint8(offs++, 0);
  view.setUint8(offs++, 0);
  view.setUint8(offs++, 0);
  view.setUint32(offs, payloadSize, true); offs += 4;

  // Payload
  view.setUint32(offs, pointCount, true); offs += 4;
  view.setUint16(offs, roadCount, true); offs += 2;
  view.setUint16(offs, nextCount, true); offs += 2;

  // roads
  for (let i=0;i<roadsEncoded.length;i++){
    const arr = roadsEncoded[i];
    view.setUint8(offs++, arr.length);
    new Uint8Array(buf, offs, arr.length).set(arr);
    offs += arr.length;
  }
  // nexts
  for (let i=0;i<nextsEncoded.length;i++){
    const arr = nextsEncoded[i];
    view.setUint8(offs++, arr.length);
    new Uint8Array(buf, offs, arr.length).set(arr);
    offs += arr.length;
  }

  // points
  // Build index maps for roads/nexts
  const roadIdxMap = {};
  roadsList.forEach((s,i)=>roadIdxMap[s]=i);
  const nextIdxMap = {};
  nextsList.forEach((s,i)=>nextIdxMap[s]=i);

  for (let i=0;i<pointCount;i++){
    const p = parsedPoints[i];
    const latI = Math.round(p.lat * 1e6);
    const lonI = Math.round(p.lon * 1e6);
    view.setInt32(offs, latI, true); offs += 4;
    view.setInt32(offs, lonI, true); offs += 4;
    const actionId = actionMap[p.action] ?? (actionMap['none'] ?? 0);
    view.setUint8(offs++, actionId);
    const rIdx = p.road ? (roadIdxMap[p.road] ?? 0) : 0;
    const nIdx = p.next ? (nextIdxMap[p.next] ?? 0) : 0;
    view.setUint8(offs++, rIdx & 0xFF);
    view.setUint8(offs++, nIdx & 0xFF);
    view.setUint8(offs++, 0); // reserved
  }

  if (offs !== totalSize) {
    console.error('offs mismatch', offs, totalSize);
  }
  encodedBuffer = buf;
  log('Built binary payload bytes=' + totalSize);
  return buf;
}

/* ===== BLE actions ===== */
document.getElementById('btnScan').addEventListener('click', async () => {
  try {
    log('üîç Qu√©t BLE...');
    const device = await navigator.bluetooth.requestDevice({
      filters: [{services: [SERVICE_UUID]}],
      optionalServices: [SERVICE_UUID]
    });
    devices[device.id] = device;
    const opt = new Option(device.name || device.id, device.id);
    document.getElementById('deviceList').appendChild(opt);
    document.getElementById('deviceList').value = device.id;
    log('Th√™m thi·∫øt b·ªã:', device.name || device.id);
  } catch (e) {
    log('BLE scan l·ªói:', e);
  }
});

document.getElementById('btnConnect').addEventListener('click', async () => {
  const sel = document.getElementById('deviceList').value;
  const dev = devices[sel];
  if (!dev) return alert('Ch∆∞a ch·ªçn thi·∫øt b·ªã');
  try {
    gattServer = await dev.gatt.connect();
    const service = await gattServer.getPrimaryService(SERVICE_UUID);
    writeChar = await service.getCharacteristic(CHAR_UUID);
    selectedDevice = dev;
    log('‚úÖ K·∫øt n·ªëi:', dev.name || dev.id);
    document.getElementById('status').textContent = 'ƒê√É K·∫æT N·ªêI';
    // hide scan
    document.getElementById('btnScan').style.display = 'none';
    document.getElementById('deviceList').style.display = 'none';
    document.getElementById('btnConnect').style.display = 'none';
  } catch (e) {
    log('K·∫øt n·ªëi l·ªói:', e);
  }
});

document.getElementById('btnDisconnect').addEventListener('click', () => {
  if (selectedDevice && selectedDevice.gatt.connected) {
    selectedDevice.gatt.disconnect();
    log('Ng·∫Øt k·∫øt n·ªëi');
    document.getElementById('status').textContent = 'Ch∆∞a k·∫øt n·ªëi';
    document.getElementById('btnScan').style.display = '';
    document.getElementById('deviceList').style.display = '';
    document.getElementById('btnConnect').style.display = '';
  }
});

async function bleWriteArrayBuffer(buf) {
  if (!writeChar) throw new Error('No characteristic');
  const MAX_CHUNK = 180; // safe value
  const total = buf.byteLength;
  const u8 = new Uint8Array(buf);
  for (let i=0;i<total;i+=MAX_CHUNK) {
    const slice = u8.slice(i, i + MAX_CHUNK);
    await writeChar.writeValue(slice);
    await new Promise(r=>setTimeout(r, 6)); // small gap
    log(`Sent chunk ${i}/${total}`);
  }
}

document.getElementById('btnSend').addEventListener('click', async () => {
  if (!writeChar) return alert('Ch∆∞a k·∫øt n·ªëi BLE');
  if (!parsedPoints || parsedPoints.length===0) return alert('Ch∆∞a c√≥ d·ªØ li·ªáu GPX (n·∫°p file tr∆∞·ªõc)');
  const buf = buildBinary();
  if (!buf) return;
  try {
    log('üì§ B·∫Øt ƒë·∫ßu g·ª≠i binary...');
    await bleWriteArrayBuffer(buf);
    log('‚úÖ G·ª≠i xong');
  } catch (e) {
    log('G·ª≠i l·ªói:', e);
  }
});
</script>
</body>
</html>
