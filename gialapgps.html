<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<title>OSM Navigation + BLE (Scan, Connect, Simulate)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  body{font-family:Arial;margin:0}
  #top { padding:10px; background:#f4f4f4; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  #map{height:60vh}
  input[type="text"]{padding:6px; width:260px}
  button{padding:6px 10px}
  #devices { margin-left:8px; }
  #log { height:160px; overflow:auto; padding:8px; background:#fff; border-top:1px solid #ddd; font-size:13px; }
  .small { font-size:13px; color:#444; }
</style>
</head>
<body>

<div id="top">
  <div>
    <strong>ƒêi·ªÉm ƒë·∫øn:</strong>
    <input id="destInput" type="text" placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ (v√≠ d·ª•: Ben Thanh, Ho Chi Minh)" />
    <button id="btnRoute">T√≠nh ƒë∆∞·ªùng</button>
  </div>

  <div>
    <button id="btnScan">üîç Qu√©t BLE</button>
    <select id="deviceList" style="min-width:220px"></select>
    <button id="btnConnect">K·∫øt n·ªëi</button>
    <button id="btnDisconnect">Ng·∫Øt</button>
  </div>

  <div>
    <button id="btnSimStart">‚ñ∂ Start Simulate</button>
    <button id="btnSimStop">‚è∏ Stop</button>
    <label class="small">(Ph·∫£i CONNECT tr∆∞·ªõc khi simulate ƒë·ªÉ g·ª≠i BLE)</label>
  </div>
</div>

<div id="map"></div>
<div id="log"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>
/* ====== C·∫•u h√¨nh BLE UUID (ph·∫£i gi·ªëng ESP32 c·ªßa b·∫°n) ====== */
const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const CHAR_UUID    = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

/* ====== Map kh·ªüi t·∫°o ====== */
const map = L.map('map').setView([10.762622, 106.660172], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '¬© OpenStreetMap contributors'
}).addTo(map);

let userMarker = L.marker([10.762622, 106.660172]).addTo(map);
let routeLine = null;

/* ====== UI elements ====== */
const btnScan = document.getElementById('btnScan');
const deviceList = document.getElementById('deviceList');
const btnConnect = document.getElementById('btnConnect');
const btnDisconnect = document.getElementById('btnDisconnect');
const btnRoute = document.getElementById('btnRoute');
const destInput = document.getElementById('destInput');
const logEl = document.getElementById('log');
const btnSimStart = document.getElementById('btnSimStart');
const btnSimStop = document.getElementById('btnSimStop');

/* ====== State BLE ====== */
let knownDevices = {}; // id -> device object
let connectedDevice = null;
let gattServer = null;
let writeChar = null;

/* ====== Logging helper ====== */
function log(...args){
  const line = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
  logEl.innerText = (new Date().toLocaleTimeString()) + '  ' + line + '\n' + logEl.innerText;
}

/* ====== Scan BLE - must be triggered by user gesture ====== */
btnScan.addEventListener('click', async () => {
  try {
    log('Y√™u c·∫ßu ch·ªçn thi·∫øt b·ªã (m·ªü h·ªôp ch·ªçn c·ªßa tr√¨nh duy·ªát)...');
    const device = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: [SERVICE_UUID]
    });
    if (!knownDevices[device.id]) {
      knownDevices[device.id] = device;
      const opt = document.createElement('option');
      opt.value = device.id;
      opt.text = device.name || ('Device ' + device.id.slice(0,6));
      deviceList.appendChild(opt);
      log('Thi·∫øt b·ªã th√™m v√†o danh s√°ch:', device.name || device.id);
      deviceList.value = device.id;
    } else {
      log('Thi·∫øt b·ªã ƒë√£ t·ªìn t·∫°i trong danh s√°ch:', device.name || device.id);
      deviceList.value = device.id;
    }
  } catch (err) {
    log('L·ªói khi qu√©t:', err);
  }
});

/* ====== Connect to selected device ====== */
btnConnect.addEventListener('click', async () => {
  const id = deviceList.value;
  if (!id) { alert('Ch∆∞a ch·ªçn thi·∫øt b·ªã'); return; }
  const device = knownDevices[id];
  if (!device) { alert('Thi·∫øt b·ªã ƒë√£ b·ªã m·∫•t, h√£y qu√©t l·∫°i'); return; }

  try {
    log('K·∫øt n·ªëi t·ªõi thi·∫øt b·ªã...', device.name || device.id);
    gattServer = await device.gatt.connect();
    connectedDevice = device;
    log('GATT connected');

    const service = await gattServer.getPrimaryService(SERVICE_UUID);
    writeChar = await service.getCharacteristic(CHAR_UUID);
    log('L·∫•y characteristic ghi th√†nh c√¥ng');

    // optional: listen for disconnect
    device.addEventListener('gattserverdisconnected', () => {
      log('Device disconnected:', device.name || device.id);
      connectedDevice = null;
      gattServer = null;
      writeChar = null;
    });

    alert('K·∫øt n·ªëi BLE th√†nh c√¥ng: ' + (device.name || device.id));
  } catch (err) {
    log('K·∫øt n·ªëi l·ªói:', err);
    alert('K·∫øt n·ªëi l·ªói: ' + (err.message || err));
  }
});

/* ====== Disconnect ====== */
btnDisconnect.addEventListener('click', () => {
  if (connectedDevice && connectedDevice.gatt.connected) {
    connectedDevice.gatt.disconnect();
    log('ƒê√£ ng·∫Øt k·∫øt n·ªëi');
  } else {
    log('Kh√¥ng c√≥ thi·∫øt b·ªã k·∫øt n·ªëi');
  }
});

/* ====== Send short message to ESP32 (string) ====== */
async function sendToESP(msg){
  if (!writeChar) {
    log('Ch∆∞a c√≥ characteristic ƒë·ªÉ ghi - ch∆∞a k·∫øt n·ªëi?');
    return;
  }
  try {
    const enc = new TextEncoder();
    await writeChar.writeValue(enc.encode(msg));
    log('G·ª≠i t·ªõi ESP32:', msg);
  } catch (err) {
    log('L·ªói g·ª≠i BLE:', err);
  }
}

/* ====== ROUTING (OSRM) ====== */
async function geocode(q){
  const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`;
  try {
    const res = await fetch(url);
    const data = await res.json();
    if (!data || data.length === 0) return null;
    return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon), display_name: data[0].display_name };
  } catch(e) {
    log('Geocode l·ªói:', e);
    return null;
  }
}

async function computeRoute(origLat, origLon, destLat, destLon){
  const url = `https://router.project-osrm.org/route/v1/driving/${origLon},${origLat};${destLon},${destLat}?overview=full&geometries=geojson&steps=true`;
  const res = await fetch(url);
  const data = await res.json();
  if (!data.routes || data.routes.length === 0) {
    throw new Error('Kh√¥ng t√¨m ƒë∆∞·ªùng');
  }
  return data.routes[0];
}

/* ====== Use current position as origin (get once) ====== */
async function getCurrentPositionPromise(){
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) return reject(new Error('GPS kh√¥ng h·ªó tr·ª£'));
    navigator.geolocation.getCurrentPosition(p => resolve(p.coords), err => reject(err), { enableHighAccuracy: true, timeout:10000 });
  });
}

/* ====== Button route behavior ====== */
let simulatedInterval = null;
let routeCoordinates = []; // array of [lat,lng]
let osrmSteps = []; // steps array from OSRM
let currentSimIndex = 0;

btnRoute.addEventListener('click', async () => {
  const destText = destInput.value.trim();
  if (!destText) { alert('Nh·∫≠p ƒëi·ªÉm ƒë·∫øn'); return; }

  try {
    log('L·∫•y v·ªã tr√≠ hi·ªán t·∫°i...');
    const cur = await getCurrentPositionPromise();
    const originLat = cur.latitude;
    const originLon = cur.longitude;
    userMarker.setLatLng([originLat, originLon]);
    map.setView([originLat, originLon], 14);
    log('V·ªã tr√≠ hi·ªán t·∫°i:', originLat.toFixed(6), originLon.toFixed(6));

    log('Geocode ƒëi·ªÉm ƒë·∫øn...');
    const dest = await geocode(destText);
    if (!dest) { alert('Kh√¥ng t√¨m th·∫•y ƒë·ªãa ƒëi·ªÉm'); return; }
    log('ƒê·ªãa ƒëi·ªÉm t√¨m ƒë∆∞·ª£c:', dest.display_name, dest.lat, dest.lon);

    log('T√≠nh ƒë∆∞·ªùng v·ªõi OSRM...');
    const route = await computeRoute(originLat, originLon, dest.lat, dest.lon);

    // v·∫Ω path
    const coords = route.geometry.coordinates.map(c => [c[1], c[0]]);
    routeCoordinates = coords;
    if (routeLine) map.removeLayer(routeLine);
    routeLine = L.polyline(coords, {color:'blue', weight:5, opacity:0.8}).addTo(map);
    map.fitBounds(routeLine.getBounds());

    if (route.legs && route.legs.length && route.legs[0].steps) {
      osrmSteps = route.legs[0].steps;
      log('C√≥', osrmSteps.length, 'b∆∞·ªõc.');
      log('B∆∞·ªõc 1:', osrmSteps[0].maneuver.instruction || osrmSteps[0].maneuver.type || JSON.stringify(osrmSteps[0].maneuver));
    } else {
      osrmSteps = [];
      log('Kh√¥ng c√≥ steps chi ti·∫øt t·ª´ OSRM');
    }

    currentSimIndex = 0;
    userMarker.setLatLng(routeCoordinates[0]);
    map.panTo(routeCoordinates[0]);
    log('Route ready. B·∫°n c√≥ th·ªÉ b·∫•m Start Simulate ƒë·ªÉ m√¥ ph·ªèng di chuy·ªÉn v√† g·ª≠i BLE.');
  } catch (err) {
    log('L·ªói t√≠nh ƒë∆∞·ªùng:', err);
    alert('L·ªói: ' + (err.message || err));
  }
});

/* ====== Simulation: move along routeCoordinates, send formatted distance + direction to ESP32 ====== */
btnSimStart.addEventListener('click', () => {
  if (!routeCoordinates || routeCoordinates.length < 2) { alert('Ch∆∞a c√≥ route'); return; }
  if (!writeChar) log('Ch√∫ √Ω: ch∆∞a k·∫øt n·ªëi BLE, ch·ªâ m√¥ ph·ªèng map (kh√¥ng g·ª≠i).');
  if (simulatedInterval) { clearInterval(simulatedInterval); simulatedInterval = null; }

  // chu·∫©n b·ªã danh s√°ch ƒëi·ªÉm qu·∫πo, filter ch·ªâ c√°c b∆∞·ªõc c√≥ modifier ƒë·ªÉ h∆∞·ªõng d·∫´n ch√≠nh x√°c
  const maneuvers = osrmSteps.map(s => {
    return {
      lat: s.maneuver.location[1],
      lon: s.maneuver.location[0],
      modifier: (s.maneuver.modifier || 'straight'),
      instruction: s.maneuver.instruction || (s.name || '')
    };
  });

  simulatedInterval = setInterval(async () => {
    if (currentSimIndex >= routeCoordinates.length) {
      clearInterval(simulatedInterval);
      log('Simulation finished: reached end');
      if (writeChar) await sendToESP('ƒê√£ ƒë·∫øn n∆°i');
      return;
    }

    const pos = routeCoordinates[currentSimIndex];
    userMarker.setLatLng(pos);
    map.panTo(pos);

    // T√¨m ƒëi·ªÉm qu·∫πo ti·∫øp theo m√† user ch∆∞a t·ªõi (c√°ch > 5m)
    let nextMan = null;
    for (let i = 0; i < maneuvers.length; i++) {
      const distToMan = haversine(pos[0], pos[1], maneuvers[i].lat, maneuvers[i].lon);
      if (distToMan > 5) {
        nextMan = maneuvers[i];
        break;
      }
    }
    if (!nextMan && routeCoordinates.length) {
      const last = routeCoordinates[routeCoordinates.length - 1];
      nextMan = { lat: last[0], lon: last[1], modifier: 'arrived' };
    }

    const d = haversine(pos[0], pos[1], nextMan.lat, nextMan.lon);
    const dir = normalizeModifier(nextMan.modifier || 'straight');

    function formatDistance(d){
      if (d >= 1000) {
        return (d/1000).toFixed(1).replace('.0','') + 'km';
      } else {
        return Math.round(d) + 'm';
      }
    }

    function directionToText(dir){
      switch(dir) {
        case 'left': return 'qu·∫πo tr√°i';
        case 'right': return 'qu·∫πo ph·∫£i';
        case 'uturn': return 'quay ƒë·∫ßu';
        case 'straight': return 'ƒëi th·∫≥ng';
        case 'arrived': return 'ƒë√£ ƒë·∫øn n∆°i';
        case 'roundabout': return 'v√†o v√≤ng xuy·∫øn';
        case 'sharp left': return 'qu·∫πo tr√°i g·∫Øt';
        case 'slight left': return 'r·∫Ω nh·∫π tr√°i';
        case 'sharp right': return 'qu·∫πo ph·∫£i g·∫Øt';
        case 'slight right': return 'r·∫Ω nh·∫π ph·∫£i';
        default: return dir;
      }
    }

    const distText = formatDistance(d);
    const dirText = directionToText(dir);
    const message = dir === 'arrived' ? 'ƒê√£ ƒë·∫øn n∆°i' : `C√≤n ${distText} n·ªØa ${dirText}`;

    if (writeChar) await sendToESP(message);
    log('Sim pos idx', currentSimIndex, '-> g·ª≠i:', message);

    currentSimIndex += 1;  // tƒÉng ch·∫≠m ƒë·ªÉ ƒë·∫øm l√πi ch√≠nh x√°c
  }, 1000);
});

/* ====== Stop simulation ====== */
btnSimStop.addEventListener('click', () => {
  if (simulatedInterval) {
    clearInterval(simulatedInterval);
    simulatedInterval = null;
    log('Simulation stopped');
  }
});

/* ====== Utilities ====== */
function deg2rad(d){ return d * Math.PI/180; }
function haversine(lat1, lon1, lat2, lon2) {
  const R=6371000;
  const dLat = deg2rad(lat2-lat1);
  const dLon = deg2rad(lon2-lon1);
  const a = Math.sin(dLat/2)*Math.sin(dLat/2) +
            Math.cos(deg2rad(lat1))*Math.cos(deg2rad(lat2)) *
            Math.sin(dLon/2)*Math.sin(dLon/2);
  const c = 2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R*c;
}
function normalizeModifier(m){
  m = (m||'straight').toLowerCase();
  if (m.includes('left')) return 'left';
  if (m.includes('right')) return 'right';
  if (m.includes('u')) return 'uturn';
  if (m.includes('straight') || m.includes('continue')) return 'straight';
  if (m.includes('roundabout')) return 'roundabout';
  return m;
}

log('Trang s·∫µn s√†ng. L∆∞u √Ω: b·∫•m "Qu√©t BLE" ƒë·ªÉ ch·ªçn thi·∫øt b·ªã, ch·ªçn thi·∫øt b·ªã trong list v√† b·∫•m Connect tr∆∞·ªõc khi g·ª≠i.');
</script>
</body>
</html>

