<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <title>OSM Navigation + BLE</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #sentDataContainer {
      padding: 8px 12px;
      background: #eef6ff;
      font-size: 12px;
      max-height: 120px;
      overflow: auto;
      border-bottom: 1px solid #ccc;
      flex-shrink: 0;
    }
    #sentData {
      width: 100%;
      height: 80px;
      font-family: monospace;
      white-space: pre-wrap;
      overflow-wrap: break-word;
      resize: none;
    }
    #copyBtn {
      margin-top: 6px;
      font-size: 12px;
      padding: 4px 8px;
      cursor: pointer;
    }
    #map {
      flex: 1 1 auto;
      height: auto;
    }
    #controls {
      padding: 12px 10px;
      background: #f9f9f9;
      border-top: 1px solid #ccc;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    #controls > div {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    input[type="text"] {
      padding: 6px 8px;
      width: 250px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    select {
      padding: 6px 8px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #ccc;
      min-width: 220px;
    }
    button {
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #007bff;
      background: #007bff;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:hover {
      background: #0056b3;
    }
    #progress {
      font-weight: 600;
      color: green;
      min-width: 130px;
      text-align: center;
    }
    progress {
      width: 200px;
      height: 14px;
      border-radius: 6px;
      overflow: hidden;
    }
  </style>
</head>
<body>

<div id="sentDataContainer">
  <strong>D·ªØ li·ªáu ƒë√£ g·ª≠i xu·ªëng ESP32:</strong>
  <textarea id="sentData" readonly></textarea>
  <button id="copyBtn">üìã Copy d·ªØ li·ªáu</button>
</div>

<div id="map"></div>

<div id="controls">
  <div>
    <strong>ƒêi·ªÉm ƒë·∫øn:</strong>
    <input id="destInput" type="text" placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ (VD: B·∫øn Th√†nh)" />
    <button id="btnRoute">T√≠nh ƒë∆∞·ªùng</button>
  </div>

  <div>
    <button id="btnScan">üîç Qu√©t BLE</button>
    <select id="deviceList" style="min-width:220px"></select>
    <button id="btnConnect">K·∫øt n·ªëi</button>
    <button id="btnDisconnect">Ng·∫Øt</button>
  </div>

  <div>
    <strong>Tuy·∫øn ƒë∆∞·ªùng:</strong>
    <select id="routeSelect" style="min-width:240px"></select>
  </div>

  <div>
    <button id="btnSendRoute">‚¨á G·ª≠i d·ªØ li·ªáu Route</button>
    <span id="progress">Ch∆∞a g·ª≠i</span>
    <progress id="progressBar" value="0" max="100"></progress>
  </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

const map = L.map('map').setView([10.762622, 106.660172], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '¬© OpenStreetMap contributors'
}).addTo(map);

let markers = [];
let routeLines = [];
let currentPositionMarker = null;
let knownDevices = {}, connectedDevice = null, gattServer = null, writeChar = null;

let routesData = [];  // M·∫£ng l∆∞u nhi·ªÅu tuy·∫øn ƒë∆∞·ªùng (OSRM tr·∫£ v·ªÅ)
let fullRoute = [];   // route ƒëi·ªÉm r·∫Ω ƒë·ªÉ g·ª≠i

// --- HI·ªÇN TH·ªä V·ªä TR√ç HI·ªÜN T·∫†I LI√äN T·ª§C V√Ä CH√çNH X√ÅC ---
function onLocationFound(e) {
  const latlng = e.latlng;

  if (!currentPositionMarker) {
    currentPositionMarker = L.marker(latlng, {title: "V·ªã tr√≠ hi·ªán t·∫°i"}).addTo(map);
  } else {
    currentPositionMarker.setLatLng(latlng);
  }
}

function onLocationError(e) {
  alert("Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i: " + e.message);
}

map.locate({watch: true, setView: true, maxZoom: 16, enableHighAccuracy: true});
map.on('locationfound', onLocationFound);
map.on('locationerror', onLocationError);

// --- H·ªñ TR·ª¢ CHUY·ªÇN CH·ªÆ C√ì D·∫§U SANG KH√îNG D·∫§U ---
function removeAccent(str) {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

// --- L·∫§Y TO·∫† ƒê·ªò T·ª™ TEXT (ƒê·ªäA CH·ªà) ---
async function geocode(q) {
  const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
  const js = await res.json();
  return js.length ? { lat: +js[0].lat, lon: +js[0].lon } : null;
}

// --- T√çNH ƒê∆Ø·ªúNG B·ªò V·ªöI OSRM ---
async function computeRoute(lat0, lon0, lat1, lon1) {
  // L·∫•y 3 tuy·∫øn ƒë·ªÉ ch·ªçn l·ª±a n·∫øu c√≥
  const url = `https://router.project-osrm.org/route/v1/walking/${lon0},${lat0};${lon1},${lat1}?overview=full&geometries=geojson&steps=true&alternatives=true`;
  const res = await fetch(url);
  const data = await res.json();
  return data.routes || [];
}

// --- T√çNH KHO·∫¢NG C√ÅCH GI·ªÆA 2 ƒêI·ªÇM ---
function calculateDistance(a, b) {
  const R = 6371000;
  const dLat = (b.lat - a.lat) * Math.PI / 180;
  const dLon = (b.lon - a.lon) * Math.PI / 180;
  const lat1 = a.lat * Math.PI / 180;
  const lat2 = b.lat * Math.PI / 180;
  const ua = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(ua), Math.sqrt(1 - ua));
  return R * c;
}

// --- T√åM ƒêI·ªÇM R·∫º (MANEUVER) ---
function findManeuvers(steps) {
  return steps.map(s => ({
    lat: s.maneuver.location[1],
    lon: s.maneuver.location[0],
    modifier: s.maneuver.modifier || 'straight',
    name: removeAccent(s.name || ''),
    next: removeAccent(s.destinations || '')
  }));
}

// --- L·ªåC CH·ªà G·ª¨I ƒêI·ªÇM R·∫º (KO G·ª¨I 'straight' ƒê·ªÇ GI·∫¢M D·ªÆ LI·ªÜU) ---
function buildRouteData(leg) {
  const routePoints = [];
  const maneuvers = findManeuvers(leg.steps);

  let nextTurnIndex = 0;
  for (let i = 0; i < leg.steps.length; i++) {
    const step = leg.steps[i];
    const man = maneuvers[i];
    // push ƒëi·ªÉm r·∫Ω + ƒëo·∫°n th·∫≥ng li·ªÅn sau (c·ªông kho·∫£ng c√°ch)
    routePoints.push({
      lat: man.lat,
      lon: man.lon,
      action: man.modifier,
      road: man.name,
      next: man.next,
      dist: Math.round(step.distance)
    });
  }
  return routePoints;
}

// --- V·∫º ƒê∆Ø·ªúNG TR√äN B·∫¢N ƒê·ªí ---
function drawRouteOnMap(route, color = 'blue') {
  if (!route) return;
  const latlngs = route.map(p => [p.lat, p.lon]);
  const poly = L.polyline(latlngs, { color: color, weight: 5, opacity: 0.7 });
  poly.addTo(map);
  routeLines.push(poly);
}

// --- X√ìA ƒê∆Ø·ªúNG C≈® ---
function clearRoutes() {
  routeLines.forEach(l => map.removeLayer(l));
  routeLines = [];
}

// --- X·ª¨ L√ù KHI NG∆Ø·ªúI CH·ªåN TUY·∫æN ƒê∆Ø·ªúNG ---
function selectRoute(index) {
  clearRoutes();
  if (index < 0 || index >= routesData.length) return;

  const route = routesData[index];
  fullRoute = buildRouteData(route.legs[0]);  // L·∫•y leg ƒë·∫ßu, gi·∫£ ƒë·ªãnh ƒëi b·ªô 1 leg
  drawRouteOnMap(fullRoute, 'blue');

  // Hi·ªÉn th·ªã info tuy·∫øn tr√™n select option
  const opt = document.getElementById('routeSelect').options[index];
  opt.text = `Tuy·∫øn ${index + 1}: ${Math.round(route.distance/1000)} km - ${Math.round(route.duration/60)} ph√∫t`;

  // Ch·ªçn l·∫°i option (ph√≤ng l·ªói)
  document.getElementById('routeSelect').value = index;
}
<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <title>OSM Navigation + BLE</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #sentDataContainer {
      padding: 8px 12px;
      background: #eef6ff;
      font-size: 12px;
      max-height: 120px;
      overflow: auto;
      border-bottom: 1px solid #ccc;
      flex-shrink: 0;
    }
    #sentData {
      width: 100%;
      height: 80px;
      font-family: monospace;
      white-space: pre-wrap;
      overflow-wrap: break-word;
      resize: none;
    }
    #copyBtn {
      margin-top: 6px;
      font-size: 12px;
      padding: 4px 8px;
      cursor: pointer;
    }
    #map {
      flex: 1 1 auto;
      height: auto;
    }
    #controls {
      padding: 12px 10px;
      background: #f9f9f9;
      border-top: 1px solid #ccc;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    #controls > div {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    input[type="text"] {
      padding: 6px 8px;
      width: 250px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    select {
      padding: 6px 8px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #ccc;
      min-width: 220px;
    }
    button {
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #007bff;
      background: #007bff;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:hover {
      background: #0056b3;
    }
    #progress {
      font-weight: 600;
      color: green;
      min-width: 130px;
      text-align: center;
    }
    progress {
      width: 200px;
      height: 14px;
      border-radius: 6px;
      overflow: hidden;
    }
  </style>
</head>
<body>

<div id="sentDataContainer">
  <strong>D·ªØ li·ªáu ƒë√£ g·ª≠i xu·ªëng ESP32:</strong>
  <textarea id="sentData" readonly></textarea>
  <button id="copyBtn">üìã Copy d·ªØ li·ªáu</button>
</div>

<div id="map"></div>

<div id="controls">
  <div>
    <strong>ƒêi·ªÉm ƒë·∫øn:</strong>
    <input id="destInput" type="text" placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ (VD: B·∫øn Th√†nh)" />
    <button id="btnRoute">T√≠nh ƒë∆∞·ªùng</button>
  </div>

  <div>
    <button id="btnScan">üîç Qu√©t BLE</button>
    <select id="deviceList" style="min-width:220px"></select>
    <button id="btnConnect">K·∫øt n·ªëi</button>
    <button id="btnDisconnect">Ng·∫Øt</button>
  </div>

  <div>
    <strong>Tuy·∫øn ƒë∆∞·ªùng:</strong>
    <select id="routeSelect" style="min-width:240px"></select>
  </div>

  <div>
    <button id="btnSendRoute">‚¨á G·ª≠i d·ªØ li·ªáu Route</button>
    <span id="progress">Ch∆∞a g·ª≠i</span>
    <progress id="progressBar" value="0" max="100"></progress>
  </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

const map = L.map('map').setView([10.762622, 106.660172], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '¬© OpenStreetMap contributors'
}).addTo(map);

let markers = [];
let routeLines = [];
let currentPositionMarker = null;
let knownDevices = {}, connectedDevice = null, gattServer = null, writeChar = null;

let routesData = [];  // M·∫£ng l∆∞u nhi·ªÅu tuy·∫øn ƒë∆∞·ªùng (OSRM tr·∫£ v·ªÅ)
let fullRoute = [];   // route ƒëi·ªÉm r·∫Ω ƒë·ªÉ g·ª≠i

// --- HI·ªÇN TH·ªä V·ªä TR√ç HI·ªÜN T·∫†I LI√äN T·ª§C V√Ä CH√çNH X√ÅC ---
function onLocationFound(e) {
  const latlng = e.latlng;

  if (!currentPositionMarker) {
    currentPositionMarker = L.marker(latlng, {title: "V·ªã tr√≠ hi·ªán t·∫°i"}).addTo(map);
  } else {
    currentPositionMarker.setLatLng(latlng);
  }
}

function onLocationError(e) {
  alert("Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i: " + e.message);
}

map.locate({watch: true, setView: true, maxZoom: 16, enableHighAccuracy: true});
map.on('locationfound', onLocationFound);
map.on('locationerror', onLocationError);

// --- H·ªñ TR·ª¢ CHUY·ªÇN CH·ªÆ C√ì D·∫§U SANG KH√îNG D·∫§U ---
function removeAccent(str) {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

// --- L·∫§Y TO·∫† ƒê·ªò T·ª™ TEXT (ƒê·ªäA CH·ªà) ---
async function geocode(q) {
  const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
  const js = await res.json();
  return js.length ? { lat: +js[0].lat, lon: +js[0].lon } : null;
}

// --- T√çNH ƒê∆Ø·ªúNG B·ªò V·ªöI OSRM ---
async function computeRoute(lat0, lon0, lat1, lon1) {
  // L·∫•y 3 tuy·∫øn ƒë·ªÉ ch·ªçn l·ª±a n·∫øu c√≥
  const url = `https://router.project-osrm.org/route/v1/walking/${lon0},${lat0};${lon1},${lat1}?overview=full&geometries=geojson&steps=true&alternatives=true`;
  const res = await fetch(url);
  const data = await res.json();
  return data.routes || [];
}

// --- T√çNH KHO·∫¢NG C√ÅCH GI·ªÆA 2 ƒêI·ªÇM ---
function calculateDistance(a, b) {
  const R = 6371000;
  const dLat = (b.lat - a.lat) * Math.PI / 180;
  const dLon = (b.lon - a.lon) * Math.PI / 180;
  const lat1 = a.lat * Math.PI / 180;
  const lat2 = b.lat * Math.PI / 180;
  const ua = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(ua), Math.sqrt(1 - ua));
  return R * c;
}

// --- T√åM ƒêI·ªÇM R·∫º (MANEUVER) ---
function findManeuvers(steps) {
  return steps.map(s => ({
    lat: s.maneuver.location[1],
    lon: s.maneuver.location[0],
    modifier: s.maneuver.modifier || 'straight',
    name: removeAccent(s.name || ''),
    next: removeAccent(s.destinations || '')
  }));
}

// --- L·ªåC CH·ªà G·ª¨I ƒêI·ªÇM R·∫º (KO G·ª¨I 'straight' ƒê·ªÇ GI·∫¢M D·ªÆ LI·ªÜU) ---
function buildRouteData(leg) {
  const routePoints = [];
  const maneuvers = findManeuvers(leg.steps);

  let nextTurnIndex = 0;
  for (let i = 0; i < leg.steps.length; i++) {
    const step = leg.steps[i];
    const man = maneuvers[i];
    // push ƒëi·ªÉm r·∫Ω + ƒëo·∫°n th·∫≥ng li·ªÅn sau (c·ªông kho·∫£ng c√°ch)
    routePoints.push({
      lat: man.lat,
      lon: man.lon,
      action: man.modifier,
      road: man.name,
      next: man.next,
      dist: Math.round(step.distance)
    });
  }
  return routePoints;
}

// --- V·∫º ƒê∆Ø·ªúNG TR√äN B·∫¢N ƒê·ªí ---
function drawRouteOnMap(route, color = 'blue') {
  if (!route) return;
  const latlngs = route.map(p => [p.lat, p.lon]);
  const poly = L.polyline(latlngs, { color: color, weight: 5, opacity: 0.7 });
  poly.addTo(map);
  routeLines.push(poly);
}

// --- X√ìA ƒê∆Ø·ªúNG C≈® ---
function clearRoutes() {
  routeLines.forEach(l => map.removeLayer(l));
  routeLines = [];
}

// --- X·ª¨ L√ù KHI NG∆Ø·ªúI CH·ªåN TUY·∫æN ƒê∆Ø·ªúNG ---
function selectRoute(index) {
  clearRoutes();
  if (index < 0 || index >= routesData.length) return;

  const route = routesData[index];
  fullRoute = buildRouteData(route.legs[0]);  // L·∫•y leg ƒë·∫ßu, gi·∫£ ƒë·ªãnh ƒëi b·ªô 1 leg
  drawRouteOnMap(fullRoute, 'blue');

  // Hi·ªÉn th·ªã info tuy·∫øn tr√™n select option
  const opt = document.getElementById('routeSelect').options[index];
  opt.text = `Tuy·∫øn ${index + 1}: ${Math.round(route.distance/1000)} km - ${Math.round(route.duration/60)} ph√∫t`;

  // Ch·ªçn l·∫°i option (ph√≤ng l·ªói)
  document.getElementById('routeSelect').value = index;
}
<script>
// --- G·ª¨I D·ªÆ LI·ªÜU ƒê·ªäNH D·∫†NG {"start": {...}, "route": [...] } CHO ESP32 QUA BLE ---
async function sendRouteData() {
  if (!writeChar || !fullRoute.length || !currentPositionMarker) {
    alert('Ch∆∞a k·∫øt n·ªëi BLE ho·∫∑c ch∆∞a c√≥ d·ªØ li·ªáu tuy·∫øn ƒë∆∞·ªùng ho·∫∑c v·ªã tr√≠ hi·ªán t·∫°i!');
    return;
  }

  const start = {
    lat: currentPositionMarker.getLatLng().lat,
    lon: currentPositionMarker.getLatLng().lng
  };
  const dataToSend = {start, route: fullRoute};
  const jsonString = JSON.stringify(dataToSend);
  console.log('D·ªØ li·ªáu g·ª≠i:', jsonString);

  // Hi·ªÉn th·ªã d·ªØ li·ªáu trong textarea
  document.getElementById('sentData').value = jsonString;

  // M√£ h√≥a UTF-8 th√†nh ArrayBuffer
  const encoder = new TextEncoder();
  const encoded = encoder.encode(jsonString);

  // ESP32 th∆∞·ªùng nh·∫≠n t·ªëi ƒëa ~20 byte m·ªói l·∫ßn qua BLE (MTU ~23)
  const CHUNK_SIZE = 20;
  let offset = 0;

  document.getElementById('progressBar').value = 0;
  document.getElementById('progressBar').max = encoded.length;
  document.getElementById('progress').textContent = 'ƒêang g·ª≠i...';

  try {
    while (offset < encoded.length) {
      const chunk = encoded.slice(offset, offset + CHUNK_SIZE);
      await writeChar.writeValue(chunk);
      offset += chunk.length;
      document.getElementById('progressBar').value = offset;
    }
    document.getElementById('progress').textContent = 'G·ª≠i th√†nh c√¥ng!';
  } catch (e) {
    console.error('L·ªói g·ª≠i d·ªØ li·ªáu:', e);
    document.getElementById('progress').textContent = 'L·ªói g·ª≠i!';
  }
}

// --- S·ª∞ KI·ªÜN N√öT ---
document.getElementById('btnSendRoute').addEventListener('click', sendRouteData);

// --- X·ª¨ L√ù CH·ªåN TUY·∫æN TR√äN SELECT ---
document.getElementById('routeSelect').addEventListener('change', e => {
  const idx = Number(e.target.value);
  selectRoute(idx);
});

// --- T√çNH ƒê∆Ø·ªúNG V·ªöI ƒê·ªäA CH·ªà NH·∫¨P ---
document.getElementById('btnRoute').addEventListener('click', async () => {
  const destText = document.getElementById('destInput').value.trim();
  if (!destText) {
    alert('Vui l√≤ng nh·∫≠p ƒëi·ªÉm ƒë·∫øn!');
    return;
  }
  if (!currentPositionMarker) {
    alert('Kh√¥ng c√≥ v·ªã tr√≠ hi·ªán t·∫°i!');
    return;
  }

  const destCoord = await geocode(destText);
  if (!destCoord) {
    alert('Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ!');
    return;
  }

  const startLat = currentPositionMarker.getLatLng().lat;
  const startLon = currentPositionMarker.getLatLng().lng;

  const computedRoutes = await computeRoute(startLat, startLon, destCoord.lat, destCoord.lon);
  if (!computedRoutes.length) {
    alert('Kh√¥ng t√¨m th·∫•y tuy·∫øn ƒë∆∞·ªùng!');
    return;
  }

  routesData = computedRoutes;

  // X√≥a tuy·∫øn c≈©, v·∫Ω tuy·∫øn ƒë·∫ßu ti√™n m·∫∑c ƒë·ªãnh
  clearRoutes();
  // T·∫°o option cho t·ª´ng tuy·∫øn
  const select = document.getElementById('routeSelect');
  select.innerHTML = '';
  routesData.forEach((r, i) => {
    const option = document.createElement('option');
    option.value = i;
    option.text = `Tuy·∫øn ${i + 1}: ${Math.round(r.distance/1000)} km - ${Math.round(r.duration/60)} ph√∫t`;
    select.appendChild(option);
  });

  // Hi·ªÉn th·ªã tuy·∫øn ƒë·∫ßu ti√™n lu√¥n
  selectRoute(0);
});

// --- BLE Qu√©t v√† K·∫øt n·ªëi ---
async function scanDevices() {
  try {
    const device = await navigator.bluetooth.requestDevice({
      filters: [{services: [SERVICE_UUID]}],
      optionalServices: [SERVICE_UUID]
    });
    knownDevices[device.id] = device;
    updateDeviceList();
  } catch (e) {
    alert('Qu√©t thi·∫øt b·ªã th·∫•t b·∫°i: ' + e);
  }
}

function updateDeviceList() {
  const select = document.getElementById('deviceList');
  select.innerHTML = '';
  Object.values(knownDevices).forEach(device => {
    const option = document.createElement('option');
    option.value = device.id;
    option.text = device.name || device.id;
    select.appendChild(option);
  });
}

async function connectDevice() {
  const select = document.getElementById('deviceList');
  const deviceId = select.value;
  if (!deviceId || !knownDevices[deviceId]) {
    alert('Ch∆∞a ch·ªçn thi·∫øt b·ªã!');
    return;
  }
  try {
    connectedDevice = knownDevices[deviceId];
    gattServer = await connectedDevice.gatt.connect();
    const service = await gattServer.getPrimaryService(SERVICE_UUID);
    writeChar = await service.getCharacteristic(CHAR_UUID);
    alert('K·∫øt n·ªëi th√†nh c√¥ng v·ªõi ' + connectedDevice.name);
  } catch (e) {
    alert('K·∫øt n·ªëi th·∫•t b·∫°i: ' + e);
  }
}

async function disconnectDevice() {
  if (connectedDevice && connectedDevice.gatt.connected) {
    await connectedDevice.gatt.disconnect();
    alert('ƒê√£ ng·∫Øt k·∫øt n·ªëi');
  }
  connectedDevice = null;
  gattServer = null;
  writeChar = null;
}

document.getElementById('btnScan').addEventListener('click', scanDevices);
document.getElementById('btnConnect').addEventListener('click', connectDevice);
document.getElementById('btnDisconnect').addEventListener('click', disconnectDevice);

// --- COPY D·ªÆ LI·ªÜU ƒê√É G·ª¨I ---
document.getElementById('copyBtn').addEventListener('click', () => {
  const data = document.getElementById('sentData');
  data.select();
  document.execCommand('copy');
  alert('ƒê√£ copy d·ªØ li·ªáu g·ª≠i xu·ªëng ESP32!');
});
</script>

//

