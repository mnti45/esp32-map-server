<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <title>OSM Navigation + BLE</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body { font-family: Arial; margin: 0; display: flex; flex-direction: column; height: 100vh; }
    #map { flex: 1; }
    #controls {
      padding: 10px;
      background: #f4f4f4;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      border-top: 1px solid #ccc;
    }
    input[type="text"] { padding: 6px; width: 260px }
    button { padding: 6px 10px }
    #log {
      height: 160px;
      overflow: auto;
      background: #fff;
      border-top: 1px solid #ddd;
      font-size: 13px;
      padding: 8px;
    }
    #progress {
      margin-left: 10px;
      color: green;
      font-weight: bold;
    }
  </style>
</head>
<body>

<div id="map"></div>

<div id="controls">
  <div>
    <strong>ƒêi·ªÉm ƒë·∫øn:</strong>
    <input id="destInput" type="text" placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ (v√≠ d·ª•: B·∫øn Th√†nh)" />
    <button id="btnRoute">T√≠nh ƒë∆∞·ªùng</button>
  </div>

  <div>
    <button id="btnScan">üîç Qu√©t BLE</button>
    <select id="deviceList" style="min-width:220px"></select>
    <button id="btnConnect">K·∫øt n·ªëi</button>
    <button id="btnDisconnect">Ng·∫Øt</button>
  </div>

  <div>
    <button id="btnSendRoute">‚¨á G·ª≠i d·ªØ li·ªáu Route</button>
    <span id="progress">Ch∆∞a g·ª≠i</span>
  </div>
</div>

<div id="log"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

const map = L.map('map').setView([10.762622, 106.660172], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '¬© OpenStreetMap contributors'
}).addTo(map);

let routeLine = null;
let knownDevices = {}, connectedDevice = null, gattServer = null, writeChar = null;
let fullRoute = [], fullManeuvers = [];

const logEl = document.getElementById('log');
function log(...args) {
  const line = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
  logEl.innerText = new Date().toLocaleTimeString() + '  ' + line + '\n' + logEl.innerText;
}

document.getElementById('btnScan').addEventListener('click', async () => {
  try {
    const device = await navigator.bluetooth.requestDevice({ acceptAllDevices: true, optionalServices: [SERVICE_UUID] });
    knownDevices[device.id] = device;
    const opt = new Option(device.name || `Device ${device.id.slice(0, 6)}`, device.id);
    document.getElementById('deviceList').appendChild(opt);
    document.getElementById('deviceList').value = device.id;
    log('ƒê√£ th√™m thi·∫øt b·ªã:', device.name || device.id);
  } catch (err) {
    log('L·ªói qu√©t BLE:', err);
  }
});

document.getElementById('btnConnect').addEventListener('click', async () => {
  const id = document.getElementById('deviceList').value;
  const device = knownDevices[id];
  if (!device) return alert('Ch∆∞a ch·ªçn thi·∫øt b·ªã');
  try {
    gattServer = await device.gatt.connect();
    const service = await gattServer.getPrimaryService(SERVICE_UUID);
    writeChar = await service.getCharacteristic(CHAR_UUID);
    connectedDevice = device;
    log('ƒê√£ k·∫øt n·ªëi BLE');
  } catch (err) {
    log('L·ªói k·∫øt n·ªëi:', err);
  }
});

document.getElementById('btnDisconnect').addEventListener('click', () => {
  if (connectedDevice && connectedDevice.gatt.connected) {
    connectedDevice.gatt.disconnect();
    log('ƒê√£ ng·∫Øt k·∫øt n·ªëi');
  }
});

function removeAccent(str) {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function geocode(q) {
  const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
  const js = await res.json();
  return js.length ? { lat: +js[0].lat, lon: +js[0].lon } : null;
}

async function computeRoute(lat0, lon0, lat1, lon1) {
  const url = `https://router.project-osrm.org/route/v1/cycling/${lon0},${lat0};${lon1},${lat1}?overview=full&geometries=geojson&steps=true`;
  const res = await fetch(url);
  const data = await res.json();
  return data.routes[0];
}

document.getElementById('btnRoute').addEventListener('click', async () => {
  const destText = document.getElementById('destInput').value.trim();
  if (!destText) return alert('Nh·∫≠p ƒë·ªãa ƒëi·ªÉm');

  const pos = await new Promise((res, rej) =>
    navigator.geolocation.getCurrentPosition(res, rej, {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    })
  );

  const { latitude, longitude } = pos.coords;
  const dest = await geocode(destText);
  if (!dest) return alert('Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ n√†y');

  const route = await computeRoute(latitude, longitude, dest.lat, dest.lon);
  if (!route) return alert('Kh√¥ng t√≠nh ƒë∆∞·ª£c l·ªô tr√¨nh');

  fullRoute = route.geometry.coordinates.map(c => ({ lat: c[1], lon: c[0] }));
  fullManeuvers = (route.legs[0]?.steps || []).map(s => ({
    lat: s.maneuver.location[1],
    lon: s.maneuver.location[0],
    modifier: s.maneuver.modifier || 'straight',
    name: removeAccent(s.name || ''),
    next: removeAccent(s.destinations || '')
  }));

  if (routeLine) map.removeLayer(routeLine);
  routeLine = L.polyline(fullRoute.map(p => [p.lat, p.lon]), { color: 'blue' }).addTo(map);
  map.fitBounds(routeLine.getBounds());
  log('T√≠nh ƒë∆∞·ªùng xong:', fullRoute.length, 't·ªça ƒë·ªô -', fullManeuvers.length, 'maneuver');
});

function calculateDistance(a, b) {
  const R = 6371000;
  const dLat = (b.lat - a.lat) * Math.PI / 180;
  const dLon = (b.lon - a.lon) * Math.PI / 180;
  const lat1 = a.lat * Math.PI / 180;
  const lat2 = b.lat * Math.PI / 180;

  const ua = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(ua), Math.sqrt(1 - ua));
  return R * c;
}

function findNextManeuverIndex(fromIndex = 0) {
  for (let i = fromIndex; i < fullRoute.length; i++) {
    const match = matchManeuverAt(i);
    if (match && match.modifier !== 'straight') return i;
  }
  return -1;
}

function matchManeuverAt(index) {
  const p = fullRoute[index];
  return fullManeuvers.find(m =>
    Math.abs(m.lat - p.lat) < 1e-5 && Math.abs(m.lon - p.lon) < 1e-5
  );
}

document.getElementById('btnSendRoute').addEventListener('click', async () => {
  if (!writeChar || !connectedDevice) return alert('Ch∆∞a k·∫øt n·ªëi BLE');

  const BATCH_SIZE = 5;
  const enc = new TextEncoder();
  const progressEl = document.getElementById('progress');
  const total = fullRoute.length;

  for (let i = 0; i < total; i += BATCH_SIZE) {
    const batch = [];

    for (let j = i; j < i + BATCH_SIZE && j < total; j++) {
      const p = fullRoute[j];
      const m = matchManeuverAt(j);
      const nextTurnIdx = findNextManeuverIndex(j);
      const dist = nextTurnIdx > j ? Math.round(calculateDistance(p, fullRoute[nextTurnIdx])) : 0;

      batch.push({
        lat: p.lat,
        lon: p.lon,
        action: m ? m.modifier : 'none',
        road: m ? m.name : '',
        next: m ? m.next : '',
        dist: dist
      });
    }

    const msg = JSON.stringify(batch);
    await writeChar.writeValue(enc.encode(msg));
    progressEl.innerText = `ƒê√£ g·ª≠i ${Math.min(i + BATCH_SIZE, total)}/${total} (${Math.round(Math.min(i + BATCH_SIZE, total) / total * 100)}%)`;
    await new Promise(r => setTimeout(r, 80));
  }

  log('ƒê√£ g·ª≠i to√†n b·ªô d·ªØ li·ªáu (d·∫°ng batch)');
  progressEl.innerText = 'Ho√†n t·∫•t!';
});
</script>
</body>
</html>

